---
title: "Tala project: ATAC-seq"
author: "Peter Repiscak"
date: "30/06/2021"
output:
 html_document:
  code_folding: hide
  toc: true
  toc_float: false
  theme: united
always_allow_html: true
---

```{r setup, eval=TRUE, include=FALSE}
#project setup
simpleCache::setCacheDir(cacheDir = "/home/peter_r/.cache_dir")

project_name <- "tala_atacseq"

base_dir <- "/home/peter_r"
out_dir <- file.path(base_dir, "results")
dir.create(out_dir, showWarnings = TRUE)
input_dir <- file.path(base_dir, "datasets") 
resources_dir <- file.path(base_dir, "resources")
#data_dir <- file.path(input_dir, "COUNT") # COUNT or use COUNT_AGGR;
metadata_dir <- file.path(input_dir, "metadata")

#check temp dir
tempdir()

# run parameters ----
# add params:
# add separate document
# define cutoffs and other settings ----
# - [ ] move to params: in the yaml definition
padj_perSample_GOenrich_cutoff <- 0.05
log2FC_cutoff <- log2(1.5)
padj_cutoff <- 0.1
# within promoters
# using 1000 as in Florian's code
# not using 500 as in the tutorial
promoter_dist <- 1000  # should be the same as above?!
tss_dist <- 1000 # within 500 bp of TSS; or 1000bp?

#report options
knitr::opts_chunk$set(echo = TRUE,
                      eval = TRUE,
                      cache.lazy = FALSE,
                      message=FALSE,
                      warning=FALSE,
                      dev = "png",
                      cache.path = file.path(out_dir,"report","cache/"),
                      fig.path = file.path(out_dir,"report","files/"))
options(width=100)

```


```{r run in the terminal, eval = FALSE, include = FALSE}
#rmarkdown::render(output_file = stringr::str_replace_all(date(),c(" +"="-", ":"="_")), input = here::here("/home/peter_r/scripts/tiaf1_analysis.Rmd"), output_dir = file.path("/home/peter_r/results/report","html/"))

# rmarkdown::render(input = "/home/peter_r/scripts/tiaf1_analysis.Rmd", output_file = stringr::str_replace_all(date(),c(" +"="-", ":"="_")), output_dir = file.path("/home/peter_r/results/report","html/"))
```

```{r loading libraries, message=FALSE, eval=TRUE, include=FALSE}
library("tidyverse")
library("fastcluster")
#library("LOLA")
library("simpleCache")
library("GenomicRanges")
library("rtracklayer")
library("readxl")
#library("data.table")
library("RColorBrewer")

# update docker!
# visualizing peaks:
#https://hbctraining.github.io/Intro-to-ChIPseq/lessons/10_data_visualization.html
#https://compgenomr.github.io/book/peak-calling.html
# https://www.biostars.org/p/457628/
# https://bernatgel.github.io/karyoploter_tutorial/
# https://www.bioconductor.org/packages/devel/bioc/vignettes/Gviz/inst/doc/Gviz.html
#https://github.com/ivanek/Gviz
#BiocManager::install("karyoploteR")
#install.packages("msigdbr")  # for GSEA
#install.packages("writexl")
#https://hemtools.readthedocs.io/en/latest/index.html

# cool packages:
#https://www.bioconductor.org/packages/release/bioc/vignettes/profileplyr/inst/doc/profileplyr.html
#http://bioconductor.org/packages/release/bioc/html/BiocFileCache.html
#http://bioconductor.org/packages/release/bioc/html/regioneR.html
#http://compbio.mit.edu/ChromHMM/  - use this for overall chromatin state assessment
# https://www.nature.com/articles/ncomms15011
# https://github.com/ernstlab/ConsHMM
# https://hemtools.readthedocs.io/en/latest/index.html
# https://bioconductor.org/packages/release/bioc/html/densvis.html; umap; phate; tsne
# https://github.com/KrishnaswamyLab/phateR

#BiocManager::install("BRGenomics")  # nice package for genomic data manipulation! - replace some functions using this!
# http://bioconductor.org/packages/devel/workflows/vignettes/annotation/inst/doc/Annotation_Resources.html#txdb-objects

# create annotations on the go
# e.g. BSgenome::forgeBSgenomeDataPkg
# http://bioconductor.org/packages/devel/workflows/vignettes/annotation/inst/doc/Annotation_Resources.html#txdb-objects

#library(AnnotationHub)
#library(ensembldb)
#library(soGGi)
library(Rsamtools)
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
library(BSgenome.Hsapiens.UCSC.hg38)  # cite?!
library(org.Hs.eg.db)
#BiocManager::install("BSgenome.Hsapiens.NCBI.GRCh38")
# http://bioconductor.org/packages/devel/workflows/vignettes/annotation/inst/doc/Annotation_Resources.html
#library("BSgenome.Hsapiens.NCBI.GRCh38")  # or directly use NCBI fasta
library(ChIPseeker)
#library(furrr)  # do not load as it masks some of key functions

library(ChIPQC)
#library(DT)
library(tracktables)
library(Rsubread)
library(DESeq2)
library(karyoploteR)
# Libraries based on the tutorial
# https://bioinformatics-core-shared-training.github.io/cruk-summer-school-2019/ChIPSeq/Materials/Practicals/Day5/Practical01_ATAC-seq_analysis_SS.html
# http://bioconductor.org/packages/release/bioc/vignettes/ATACseqQC/inst/doc/ATACseqQC.html

library(MotifDb)
library(Biostrings)
library(seqLogo)
library(JASPAR2020)
library(TFBSTools)
library(ggseqlogo)
library(motifmatchr)
library(chromVAR)

library(BiocParallel)

#class(BSgenome.Hsapiens.UCSC.hg38)
#metadata(BSgenome.Hsapiens.UCSC.hg38)


#BiocManager::install("ATACseqQC", "ChIPseeker", "ChIPpeakAnno", "systemPipeR")

#library("ATACseqQC")

#library("Rsubread")
#library("Rsamtools")
#library("ggplot2")
#library("devtools")
#library("magrittr")

# based on https://rockefelleruniversity.github.io/RU_ATACseq/presentations/singlepage/RU_ATAC_part2.html
# add to the Docker image!
# tracktables - Build IGV tracks and HTML reports
# R packages from: https://rockefelleruniversity.github.io/RU_ATACseq/

#BiocManager::install(c("ChIPQC", "ChIPseeker", "tracktables", "MotifDb", "universalmotif", "JASPAR2020"))

#https://www.bioconductor.org/packages/release/bioc/html/Organism.dplyr.html

# http://bioconductor.org/packages/devel/workflows/vignettes/annotation/inst/doc/Annotation_Resources.html
# https://bioconductor.org/packages/devel/bioc/vignettes/AnnotationHub/inst/doc/AnnotationHub.html
# https://bioconductor.org/packages/devel/bioc/vignettes/AnnotationHub/inst/doc/AnnotationHub-HOWTO.html

# download EnsDb.Hsapiens.v86 or newer using ensembldb; AnnotationHub (or everything using AnnotationHub!)
# BiocManager::install(c("AnnotationHub", 
#                        "Homo.sapiens",
#                        "Organism.dplyr",
#                        "TxDb.Hsapiens.UCSC.hg38.knownGene",
#                        "BSgenome.Hsapiens.UCSC.hg38",
#                        "org.Hs.eg.db",
#                        "EnsDb.Hsapiens.v86"),
#                      update = TRUE, ask = FALSE)


```

```{r loading/importing functions, message=FALSE, eval=TRUE, include=FALSE}
remove_blacklisted <- function(peak_gr=NULL, blacklisted_regions=blacklist){
  # removing regions overlapping with blacklisted
  # see https://biodatascience.github.io/compbio/bioc/ranges.html
  # If we just wanted to subset to the genes which overlap a given range, we can use overlapsAny:
  #g[overlapsAny(g, query[1])]
  #This is equivalent to the following:
  #g[g %over% query[1]] 
  
  blacklisted = sum(IRanges::overlapsAny(peak_gr, blacklisted_regions))
  blacklisted_perc = (blacklisted/length(peak_gr))*100
  #not_blacklisted = sum(!IRanges::overlapsAny(peak_gr, blacklisted_regions))
  message("Blacklisted regions regions: ", blacklisted, " (", round(blacklisted_perc,1), "%)")
  
  return(peak_gr[!IRanges::overlapsAny(peak_gr, blacklisted_regions)])
}
```

```{r loading annotations, message=FALSE, eval=TRUE, include=FALSE}
# genome used by PEPATAC
# - [ ] use in IGV viewer as well as R analysis
#gzip -cd /home/nsheff/hg38/GCA_000001405.15_GRCh38_no_alt_analysis_set.fna.gz > /home/nsheff/hg38/hg38.fa
#gzip -cd /home/nsheff/hg38/gencode.v23.primary_assembly.annotation.gtf.gz > /home/nsheff/hg38/hg38.gtf
#Homo_sapiens.GRCh38.98.gtf used in SMART-seq

# - [  ] TSS plots do not seem to work!?

# Ensembl annotation ----
# or retrieving using AnnotationHub
# https://bioconductor.org/packages/3.13/bioc/vignettes/ensembldb/inst/doc/ensembldb.html#10_Getting_or_building_EnsDb_databasespackages
# annot_hub <- AnnotationHub()
# ahDb <- query(annot_hub, pattern = c("Homo Sapiens", "EnsDb", 103))
# snapshotDate(ahDb)  # "2020-10-27"
# txdb_ah_ensembl <- ahDb[["AH89426"]]
# seqlevelsStyle(txdb_ah_ensembl) <- "UCSC"

# other options:
# original Peaks file contains chr?
#library(EnsDb.Hsapiens.v86)

#library(biomaRt)
# listMarts(host="www.ensembl.org")
# mart <- useMart(biomart="ENSEMBL_MART_ENSEMBL", host="www.ensembl.org")
# datasets <- listDatasets(mart)
# head(datasets)
# subset(datasets, grepl("hsapiens_gene_ensembl", dataset, ignore.case=TRUE))

## Retrieve the full transcript dataset for Worm:
# txdb_ensembl <- makeTxDbFromBiomart(dataset="hsapiens_gene_ensembl")
# seqlevelsStyle(txdb_ensembl) <- "UCSC"

## retrieve all genes
#gns <- genes(ahEdb)


# TxDb.Hsapiens.UCSC.hg38.knownGene
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene
#seqlevelsStyle(TxDb.Hsapiens.UCSC.hg38.knownGene)  # UCSC

#TxDb object:
# Db type: TxDb
# Supporting package: GenomicFeatures
# Data source: UCSC
# Genome: hg38
# Organism: Homo sapiens
# Taxonomy ID: 9606
# UCSC Table: knownGene
# UCSC Track: GENCODE V36
# Resource URL: http://genome.ucsc.edu/
# Type of Gene ID: Entrez Gene ID
# Full dataset: yes
# miRBase build ID: NA
# Nb of transcripts: 232184
# Db created by: GenomicFeatures package from Bioconductor
# Creation time: 2021-04-28 16:32:07 +0000 (Wed, 28 Apr 2021)
# GenomicFeatures version at creation time: 1.41.3
# RSQLite version at creation time: 2.2.6
# DBSCHEMAVERSION: 1.2

#library(EnsDb.Hsapiens.v86)
#seqlevelsStyle(EnsDb.Hsapiens.v86)

# txdb_ens <- makeTxDbFromGFF(file = "/home/peter_r/resources/Homo_sapiens.GRCh38.98.gtf",
#                         format = "auto",
#                         dataSource = "Homo_sapiens.GRCh38.98.gtf",
#                         organism = "Homo sapiens",
#                         taxonomyId = 9606)
#seqlevelsStyle(txdb_ens) NCBI, Ensembl? both?
#seqlevelsStyle(txdb_ens) <- "NCBI"

#library("AnnotationHub")
# https://bioconductor.org/packages/devel/bioc/vignettes/AnnotationHub/inst/doc/TroubleshootingTheCache.html#default-caching-location-update
#https://github.com/Bioconductor/AnnotationHub/issues/20
#curl::nslookup("annotationhub.bioconductor.org")
# annot_hub <- AnnotationHub::AnnotationHub()
# ahDb <- AnnotationHub::query(annot_hub, pattern = c("Homo Sapiens", "EnsDb", 98))
# AnnotationHub::snapshotDate(ahDb)  # "2021-05-18"
# txdb_ah_ensembl <- ahDb[["AH75011"]]
# seqlevelsStyle(txdb_ah_ensembl)  # "Ensembl"
# seqlevelsStyle(txdb_ah_ensembl) <- "NCBI" # "UCSC"

#readBStringSet
# genome_seq <- Biostrings::readDNAStringSet(filepath = "/home/peter_r/resources/GCA_000001405.15_GRCh38_no_alt_analysis_set.fna.gz")
# fasta.seqlengths("/home/peter_r/resources/GCA_000001405.15_GRCh38_no_alt_analysis_set.fna.gz")
# as(genome_seq, "XStringViews")
# alphabetFrequency(gaps(genome_seq))

mainChromosomes <- paste0("chr", c(1:22, "X", "Y"))  # , "M"

blacklist <- rtracklayer::import.bed("http://mitra.stanford.edu/kundaje/akundaje/release/blacklists/hg38-human/hg38.blacklist.bed.gz")
#blacklist <- with(fread("wget -O - http://mitra.stanford.edu/kundaje/akundaje/release/blacklists/hg38-human/hg38.blacklist.bed.gz | zcat"), GRanges(V1,IRanges(V2,V3)))

#regionDB=paste0(resources_dir, "/regions/LOLACore/hg38")
#repeats <- LOLA::getRegionSet(regionDB = regionDB, collections="ucsc_features", "rmsk.bed")#[[1]]

#saving session info
#sink(paste0(out_dir, "/session_info.txt"), append = FALSE)
# print() needed to work when used with 'Source on Save' in RStudio
# without it, sink() will save an empty file
# print(sessioninfo::session_info())
#sink()
```

# Initialization
### Loading data and metadata

```{r loading data, include=TRUE, eval=TRUE}
# Loading atac-seq data ----

# loading metadata from excel file
project_metadata_raw <- readxl::read_excel(path = file.path(metadata_dir, "atacseq_metadata_TS.xlsx"), sheet = "atacseq_metadata")

# loading peaks files
narrowPeak_files <- list.files(path = input_dir, pattern = ".*\\.narrowPeak", full.names=TRUE, recursive=TRUE)
narrowPeak_df <- data.frame(narrowPeak_files = narrowPeak_files) %>%
  dplyr::mutate(sample_name = gsub(pattern = "(.+/)(.+)(_peaks.narrowPeak)", replacement = "\\2", narrowPeak_files))

# loading bam files
bam_files <- list.files(path = input_dir, pattern = ".*_sort_dedup.bam$", full.names=TRUE, recursive=TRUE)
bam_df <- data.frame(bam_files = bam_files) %>%
  dplyr::mutate(sample_name = gsub(pattern = "(.+/)(.+)(_sort_dedup.bam)", replacement = "\\2", bam_files))

# updating metadata wiht peak and bam files information
project_metadata <- project_metadata_raw %>%
  dplyr::left_join(., narrowPeak_df, by = "sample_name") %>%
  dplyr::left_join(., bam_df, by = "sample_name") %>%
  dplyr::filter(sample_name != "Clone_D8")  # removing Clone_D8

project_metadata <- project_metadata %>%
  dplyr::mutate(sample_group = gsub(pattern = "(.+)(_.+)", replacement = "\\1", sample_name)) %>%
  dplyr::mutate(sample_group = factor(sample_group, levels = c("ND", "Patient")))
rownames(project_metadata) <- project_metadata$sample_name
```

### Quality control analysis

```{r QC analysis, include=TRUE, eval=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
#blacklist <- with(fread("wget -O - http://mitra.stanford.edu/kundaje/akundaje/release/blacklists/hg38-human/hg38.blacklist.bed.gz | zcat"),GRanges(V1,IRanges(V2,V3)))

# loading repeats regions and blacklisted regions ----
# - [ ] check about repeat regions? where are they coming from and their meaning?
# - [ ] include Hi-C data for annotation?! - enhancers
# - [ ] TFs enrichment
# - [ ] motif enrichment

# plot all sample together - all chromosomes?!
# plot only main chromosomes
# plot after blacklist removal

sample_names <- project_metadata$sample_name

if (!file.exists(paste0(out_dir, "/peak_grlist.RDS"))) {
  # loading peaks as granges
  peak_gr_raw <- purrr::map(.x = sample_names, .f = function(sample_name) {
    message("Loading peaks for: ", sample_name)
    # rtracklayer::import(project_metadata$narrowPeak_files[project_metadata$sample_name == sample_name], format = "narrowPeak")???
    ChIPseeker::readPeakFile(project_metadata$narrowPeak_files[project_metadata$sample_name == sample_name], as = "GRanges")
  }) %>% setNames(sample_names)
  
  # combine into granges list
  peak_grlist_raw <- GenomicRanges::GRangesList(peak_gr_raw)
  
  # keeping only main chromosomes ----
  # - [ ] have a quick look also on other chromosomes
  # remove non-standard chromosomes and mitochondrial!
  seqlevels(peak_grlist_raw)
  peak_gr_list <- purrr::map(.x = sample_names, .f = function(sample_name) {
    message("Removing non-standard chr from: ", sample_name)
    # rtracklayer::import(project_metadata$narrowPeak_files[project_metadata$sample_name == sample_name], format = "narrowPeak")???
    GenomeInfoDb::keepSeqlevels(peak_grlist_raw[[sample_name]],
                                value = mainChromosomes,
                                pruning.mode="coarse")
  }) %>% setNames(sample_names)
  
  #! store
  # peak granges list with main chromosomes
  peak_grlist <- GenomicRanges::GRangesList(peak_gr_list)
  seqlevels(peak_grlist)
  
  message("Saving peak_grlist")
  saveRDS(peak_grlist, file = paste0(out_dir, "/peak_grlist.RDS"))
  
} else {
  message("Loading peak_grlist")
  peak_grlist <- readRDS(file = paste0(out_dir, "/peak_grlist.RDS"))
}


# Performing QC analysis ----
if (!file.exists(paste0(out_dir, "/QC_results.RData"))){
  #genome(peak_gr_raw_list) <- "hg38"
  # https://mdeber.github.io/
  #peak_gr_list <- BRGenomics::tidyChromosomes 
  
  # coverage over chromosomes
  # also use GRangesList to calculate per sample
  # https://guangchuangyu.github.io/2016/02/covplot-supports-grangeslist/
  peak_gr_per_chr <- ChIPseeker::covplot(peak = peak_grlist,
                                         title ="ATAC-seq peaks coverage over chromosomes")
  
  #! store
  peaks_per_chr_plot <- peak_gr_per_chr + facet_grid(chr ~ .id)  # remove non-main chromosomes
  
  # looking at annotated regions 
  peak_grlist_annot <- lapply(peak_grlist, ChIPseeker::annotatePeak, 
                         TxDb=txdb,
                         tssRegion=c(-3000, 3000),
                         level = "gene",  
                         annoDb="org.Hs.eg.db", 
                         verbose=FALSE)
  
  peak_grlist_annot_bar_plot <- ChIPseeker::plotAnnoBar(peak_grlist_annot)
  peak_grlist_annot_distTSS_plot <- ChIPseeker::plotDistToTSS(peak_grlist_annot,
              title="Distribution of ATAC-seq peaks \nrelative to TSS")
  
  ggsave(peak_grlist_annot_bar_plot, filename = file.path(out_dir, "/peak_grlist_annot_bar_plot.png"))
  ggsave(peak_grlist_annot_bar_plot, filename = file.path(out_dir, "/peak_grlist_annot_bar_plot.pdf"))
  ggsave(peak_grlist_annot_distTSS_plot, filename = file.path(out_dir, "/peak_grlist_annot_distTSS_plot.png"))
   
  # constructing ChIPQCexperiment object
  atacseq_experiment_df <- project_metadata %>%
    dplyr::select(sample_name, sample_group, bam_files, narrowPeak_files) %>%
    dplyr::rename(SampleID = sample_name, 
                  Condition = sample_group,
                  bamReads = bam_files,
                  Peaks = narrowPeak_files) %>%
    dplyr::mutate(PeakCaller = "narrow")
  
  # consensus QC ----
  # - [ ] define critical QC steps?! 
  # https://rockefelleruniversity.github.io/RU_ChIPseq/presentations/slides/ChIPseq_In_Bioconductor2.html#22
  # quite expensive so save in a separate
  atacseqQC <- ChIPQC::ChIPQC(atacseq_experiment_df,
                              annotation="hg38",
                              chromosomes = mainChromosomes,  # mainChromosomes
                              consensus=FALSE, # TRUE?
                              blacklist = blacklist)
  
  # !!! really small number of reads in peaks?!
  atacseqQC_metrics <- as.data.frame(QCmetrics(atacseqQC))
  atacseqQC_SSDplot <- ChIPQC::plotSSD(atacseqQC) + xlim(0.13, 0.18)  # Standardized Standard Deviation
  # SSD is a measure of standard deviation of signal across the genome with higher scores reflecting significant pile-up of reads. SSD can therefore be used to assess both the extent of ultra high signals and the signal
  atacseqQC_CCplot <- ChIPQC::plotCC(atacseqQC, facetBy = "Sample")  # Cross-coverage plot
  
  ggsave(atacseqQC_SSDplot, filename = file.path(out_dir, "/atacseqQC_SSDplot.png"))
  ggsave(atacseqQC_CCplot, filename = file.path(out_dir, "/atacseqQC_CCplot.png"))
  
  # duplication rate
  atacseqQC_flags <- ChIPQC::flagtagcounts(atacseqQC)
  #atacseqQC_flags["DuplicateByChIPQC", ]/atacseqQC_flags["Mapped", ]
  
  # review distribution of reads across features
  atacseqQC_feature_dist <- ChIPQC::plotRegi(atacseqQC) + coord_flip() + theme_bw()
  ggsave(atacseqQC_feature_dist, filename = file.path(out_dir, "/atacseqQC_feature_dist.png"))
  
  # add to report
  # ??? invalid name for slot of class "trellis": panel
  ChIPQC::ChIPQCreport(object = atacseqQC, 
                       reportName="ATACseq_QCreport",
                       #facetBy=c("sample_group"),
                       reportFolder = paste0(out_dir, "/ATACseq_QCreport"))
  
  message("Saving QC_results")
  save(peaks_per_chr_plot, atacseqQC, atacseqQC_metrics, atacseqQC_SSDplot, atacseqQC_flags,
       file = paste0(out_dir, "/QC_results.RData"))
} else {
  
  message("Loading QC_results")
  load(file = paste0(out_dir, "/QC_results.RData"))
  
}


# Pre-processing ----
# removing blacklist regions per sample
# removing blacklist regions per sample set:
#    to generate universe of genes for enrichment?! 
#    for downstream differential accessibility analisis

# - [ ] include also repeats! as there is many more than blacklisted!

# check if remove blacklist per sample = remove blacklist per combined?!

if (!file.exists(paste0(out_dir, "/peak_grlist_filt.RDS"))){
  
  peak_gr_filt_list <- purrr::map(.x = sample_names, .f = function(sample_name) {
    message("Removing blaclisted regions from: ", sample_name)
    # rtracklayer::import(project_metadata$narrowPeak_files[project_metadata$sample_name == sample_name], format = "narrowPeak")???
    
    remove_blacklisted(peak_gr = peak_grlist[[sample_name]])
    
  }) %>% setNames(sample_names)
  
  peak_grlist_filt <- GenomicRanges::GRangesList(peak_gr_filt_list)
  message("Saving peak_grlist_filt")
  saveRDS(peak_grlist_filt, file = paste0(out_dir, "/peak_grlist_filt.RDS"))
  
} else {
  message("Loading peak_grlist_filt")
  peak_grlist_filt <- readRDS(file = paste0(out_dir, "/peak_grlist_filt.RDS"))
}

# removing per PeakSet ----
# allPeaksSet_nR <- GenomicRanges::reduce(unlist(peak_grlist))  
# 
# peaks_overlap <- list()
# for (i in 1:length(peak_grlist)) {
#     peaks_overlap[[i]] <-  IRanges::overlapsAny(allPeaksSet_nR, peak_grlist[[i]])
# }
# overlapMatrix <- do.call(cbind, peaks_overlap)
# colnames(overlapMatrix) <- names(peak_grlist)  # project_metadata$sample_name
# mcols(allPeaksSet_nR) <- overlapMatrix
#allPeaksSet_nR[1:2, ]

# similar to https://rockefelleruniversity.github.io/RU_ChIPseq/presentations/slides/ChIPseq_In_Bioconductor4.html#32
# also see part for exporting beds to visualize in IGV:
#  export.bed(ch12_HC_Peaks, "ch12_HC_Peaks.bed")
#install.packages("ggVennDiagram")
# https://github.com/gaospecial/ggVennDiagram
#ggVEnnDriagram::ggVennDiagram(allPeaksSet_nR) + scale_fill_gradient(low="blue",high = "red")
# gplots::venn(as.list(mcols(allPeaksSet_nR)))
# 
# venncounts_object <- limma::vennCounts(mcols(allPeaksSet_nR))
# limma::vennDiagram(venncounts_object)

# limma::vennDiagram(venncounts_object, 
#                    counts.col=c("red", "blue"),
#     circle.col = c("red", "blue", "green3"))
#allPeaksSet_nR_peakset_filt <- allPeaksSet_nR[!IRanges::overlapsAny(allPeaksSet_nR, blacklist)]
#identical(allPeaksSet_nR_peakset_filt, allPeaksSet_filt_nR)  # TRUE


# Annotating peaks ----

if (!file.exists(paste0(out_dir, "/allPeaksSet_filt_nR_annot.RData"))){
  allPeaksSet_filt_nR <- GenomicRanges::reduce(unlist(peak_grlist_filt)) 
  peaks_overlap <- list()
  for (i in 1:length(peak_grlist_filt)) {
    peaks_overlap[[i]] <-  IRanges::overlapsAny(allPeaksSet_filt_nR, peak_grlist_filt[[i]])
  }
  overlapMatrix <- do.call(cbind, peaks_overlap)
  colnames(overlapMatrix) <- names(peak_grlist_filt)  # project_metadata$sample_name
  mcols(allPeaksSet_filt_nR) <- overlapMatrix
  
  # annotating to get gene universe for enrichment ----
  # txdb_ah_ensembl, txdb
  length(allPeaksSet_filt_nR)
  # annotating to gene!
  # how does results differ when annotating to gene or transcript?!
  allPeaksSet_filt_nR_annot <- ChIPseeker::annotatePeak(peak = allPeaksSet_filt_nR,
                                                        tssRegion=c(-3000, 3000),
                                                        TxDb=txdb, 
                                                        level = "gene",  # "transcript" or "gene"; default is transcript
                                                        annoDb="org.Hs.eg.db")
  
  # test
  # allPeaksSet_filt_nR_annot2 <- ChIPseeker::seq2gene(seq = allPeaksSet_filt_nR,
  #                                            tssRegion=c(-1000, 1000),
  #                                            flankDistance = 3000,
  #                                            TxDb=txdb, 
  #                                            sameStrand = FALSE)
  
  allPeaksSet_filt_nR_annot_gr <- as.GRanges(allPeaksSet_filt_nR_annot)
  # defining unique identifier as a combination of entrezID_chr_start_end
  allPeaksSet_filt_nR_annot_gr$unique_geneID <- paste(allPeaksSet_filt_nR_annot_gr$geneId, as.character(seqnames(allPeaksSet_filt_nR_annot_gr)), IRanges::start(allPeaksSet_filt_nR_annot_gr), IRanges::end(allPeaksSet_filt_nR_annot_gr), sep = "_")
  message("Duplicated unique_geneID: ", sum(duplicated(allPeaksSet_filt_nR_annot_gr$unique_geneID)))
  allPeaksSet_filt_nR_annot_df <- as.data.frame(allPeaksSet_filt_nR_annot_gr)
  
  message("Saving allPeaksSet_filt_nR_annot")
  save(allPeaksSet_filt_nR, allPeaksSet_filt_nR_annot, allPeaksSet_filt_nR_annot_gr, allPeaksSet_filt_nR_annot_df, file = paste0(out_dir, "/allPeaksSet_filt_nR_annot.RData"))
} else {
  message("Loading allPeaksSet_filt_nR_annot")
  load(file = paste0(out_dir, "/allPeaksSet_filt_nR_annot.RData"))
}

# assesing distanceToTSS of annotated features 
allPeaksSet_filt_nR_annot_df_perGroup <- allPeaksSet_filt_nR_annot_df %>%
  dplyr::select(Patient, ND_01, ND_02, distanceToTSS) %>%
  tidyr::pivot_longer(., -distanceToTSS, names_to = "sample_name", values_to = "detected") %>%
  dplyr::filter(detected == TRUE)

#annot_distanceToTSS_plot <- ggplot(data=allPeaksSet_filt_nR_annot_df_perGroup, aes(x=sample_name, y=log10(abs(distanceToTSS + 1)), fill=sample_name )) + 
#  geom_boxplot() + 
#  theme_bw()
sum(abs(allPeaksSet_filt_nR_annot_df_perGroup$distanceToTSS) > 50000)/length(allPeaksSet_filt_nR_annot_df_perGroup$distanceToTSS)
# there are few extreme distances to TSS - investigate
# ?seq2gene

#! store
annot_pie_plot <- ChIPseeker::plotAnnoPie(allPeaksSet_filt_nR_annot)
annot_bar_plot <- ChIPseeker::plotAnnoBar(allPeaksSet_filt_nR_annot)
#install.packages("ggupset")
#ChIPseeker::upsetplot(peakAnno, vennpie=TRUE)
annot_distTSS_plot <- ChIPseeker::plotDistToTSS(allPeaksSet_filt_nR_annot,
              title="Distribution of ATAC-seq peaks \nrelative to TSS")

ggsave(annot_distTSS_plot, filename = file.path(out_dir, "/annot_distTSS_plot.png"))
ggsave(annot_bar_plot, filename = file.path(out_dir, "/annot_bar_plot.png"))

png(filename = file.path(out_dir, "/annot_pie_plot.png"))
ChIPseeker::plotAnnoPie(allPeaksSet_filt_nR_annot)
dev.off()

pdf(file = file.path(out_dir, "/annot_pie_plot.pdf"))
ChIPseeker::plotAnnoPie(allPeaksSet_filt_nR_annot)
dev.off()

# defining gene universe used for enrichment 
gene_universe <- unique(allPeaksSet_filt_nR_annot_df$geneId)
length(gene_universe)

# Qualitative analysis: per sample  ----
# subsetting peaks to those around TSS regions (+/- 1000) for functional analysis

# re-do with systemPiper
# allPeaksSet_filt_nR_annot_vennset <- systemPipeR::overLapper(, type="vennsets")
# allPeaksSet_filt_nR_anno_intersect <- systemPipeR::overLapper(genes_overlap_toEnrich, type="intersects")
# systemPipeR::vennPlot(allPeaksSet_filt_nR_annot_vennset)

venncounts_object <- limma::vennCounts(mcols(allPeaksSet_filt_nR))
limma::vennDiagram(venncounts_object, main="Overlapping peaks")

png(filename = file.path(out_dir, "/overlapping_peaks.png"))
limma::vennDiagram(venncounts_object, main="Overlapping peaks")
dev.off()

# nicer venn ----
# https://www.r-graph-gallery.com/14-venn-diagramm.html
# library(VennDiagram)
library(ggvenn)
#install.packages("ggvenn")

# example
# data_delete <- read.table("https://raw.githubusercontent.com/holtzy/data_to_viz/master/Example_dataset/14_SeveralIndepLists.csv", header=TRUE) 
# to_remove <- c("_|[0-9]|\\.|function|^id|script|var|div|null|typeof|opts|if|^r$|undefined|false|loaded|true|settimeout|eval|else|artist")
# data_delete <- data_delete %>% filter(!grepl(to_remove, word)) %>% filter(!word %in% stopwords('fr')) #%>% filter(!word %in% proust_stopwords()$word)

# x_delete <- list(
#     data_delete %>% filter(artist=="booba") %>% dplyr::select(word) %>% unlist() , 
#     data_delete %>% filter(artist=="nekfeu") %>% dplyr::select(word) %>% unlist() , 
#     data_delete %>% filter(artist=="georges-brassens") %>% dplyr::select(word) %>% unlist()
#     )

peak_overlaps_df <- as_tibble(mcols(allPeaksSet_filt_nR)) %>%
  #dplyr::mutate(row_sums = rowSums(peak_overlaps_df)) %>%
  tibble::rowid_to_column(var="rowid") %>%
  dplyr::mutate(value=paste0("peak", rowid)) %>%
  dplyr::select(value, ND_01, ND_02, Patient) 
  dplyr::mutate(ND_01 = ifelse(ND_01, NA, paste0("peak",rowid)),
                ND_02 = ifelse(ND_02, NA, paste0("peak",rowid)),
                Patient = ifelse(Patient, NA, paste0("peak",rowid)))
peak_overlaps_list <- list(ND_01=peak_overlaps_df$ND_01[!is.na(peak_overlaps_df$ND_01)],
                 ND_02=peak_overlaps_df$ND_02[!is.na(peak_overlaps_df$ND_02)],
                 Patient=peak_overlaps_df$Patient[!is.na(peak_overlaps_df$Patient)])
lapply(peak_overlaps_list, length)

# https://www.datanovia.com/en/blog/venn-diagram-with-r-or-rstudio-a-million-ways/go
peaks_venn <- ggvenn::ggvenn(
  peak_overlaps_df, 
  fill_color = c("#0073C2FF", "#0073C2FF", "#EFC000FF"),
  stroke_size = 0.5) + labs(title ="Overlapping ATAC-seq peaks")

ggsave(peaks_venn, filename = file.path(out_dir, "/overlapping_peaks.png"))
ggsave(peaks_venn, filename = file.path(out_dir, "/overlapping_peaks.pdf"))

#Make the plot
# peaks_venn <- VennDiagram::venn.diagram(
#   x = x_delete,
#   category.names = c("ND_01" , "ND_02" , "Patient"),
#   filename=NULL,
#   #filename = 'IMG/venn.png',
#   output = TRUE ,
#   #imagetype="png" ,
#   #height = 480 , 
#   #width = 480 , 
#   #resolution = 300,
#   #compression = "lzw",
#   #lwd = 1,
#   col=c("#440154ff", '#21908dff', '#fde725ff'),
#   #fill = c(alpha("#440154ff",0.3), alpha('#21908dff',0.3), alpha('#fde725ff',0.3)),
#   #cex = 0.5,
#   #fontfamily = "sans",
#   #cat.cex = 0.3,
#   #cat.default.pos = "outer",
#   #cat.pos = c(-27, 27, 135),
#   #cat.dist = c(0.055, 0.055, 0.085),
#   #cat.fontfamily = "sans",
#   #cat.col = c("#440154ff", '#21908dff', '#fde725ff'),
#   #rotation = 1
# )
# 
# grid.draw(peaks_venn)
```

### Per sample analysis

Analysis of peaks unique to each of the samples.

```{r perSample analysis, include=TRUE, eval=TRUE, cache=TRUE}
# creating combined reduced object:
#   used to define gene universe for enrichment analysis
#   used to find consensus peaks

#occurrences <- rowSums(as.data.frame(elementMetadata(nrToCount)))
# in two and more samples!
# in tutorial error: consensusToCount not defined?
#consensusToCount <- nrToCount[occurrences >= 2, ]  # potentially ignore Clone?!
unique_occurences <- rowSums(as.data.frame(elementMetadata(allPeaksSet_filt_nR))) == 1

# Only in patient
peaks_patient_only <- as.data.frame(allPeaksSet_filt_nR_annot_gr[(allPeaksSet_filt_nR_annot_gr$Patient == TRUE) & unique_occurences]) %>%  
  dplyr::mutate(peakOnly = "Patient")
#peaks_patient_only_TSS <- peaks_patient_only[abs(peaks_patient_only$distanceToTSS) < tss_dist]
#length(peaks_patient_only)
# Only in ND01
peaks_ND01_only <- as.data.frame(allPeaksSet_filt_nR_annot_gr[(allPeaksSet_filt_nR_annot_gr$ND_01 == TRUE) & unique_occurences]) %>%  
  dplyr::mutate(peakOnly = "ND_01")
#peaks_ND01_only_TSS <- peaks_ND01_only[abs(peaks_ND01_only$distanceToTSS) < tss_dist]
#length(peaks_ND01_only)
# Only in ND02
peaks_ND02_only <- as.data.frame(allPeaksSet_filt_nR_annot_gr[(allPeaksSet_filt_nR_annot_gr$ND_02 == TRUE) & unique_occurences]) %>%  
  dplyr::mutate(peakOnly = "ND_02")
#peaks_ND02_only_TSS <- peaks_ND02_only[abs(peaks_ND02_only$distanceToTSS) < tss_dist]
#length(peaks_ND02_only)

# enriching for genes found in unique peaks ----
#genes_overlap <- as.data.frame(allPeaksSet_filt_nR_annot_gr) do all at once!
genes_overlap <- dplyr::bind_rows(peaks_patient_only, peaks_ND01_only, peaks_ND02_only) 
table(genes_overlap$peakOnly)  

genes_overlap_toEnrich_df <- genes_overlap %>%
  dplyr::group_by(peakOnly) %>%
  dplyr::summarise(unique_genes = list(unique(geneId)))

lapply(genes_overlap_toEnrich_df$unique_genes, length)

genes_overlap_toEnrich <- genes_overlap_toEnrich_df$unique_genes
names(genes_overlap_toEnrich) <- genes_overlap_toEnrich_df$peakOnly

# identifying patient unique genes within N bp from TSS
genes_overlap_toEnrich_vennset <- systemPipeR::overLapper(genes_overlap_toEnrich, type="vennsets")
genes_overlap_toEnrich_intersect <- systemPipeR::overLapper(genes_overlap_toEnrich, type="intersects")
systemPipeR::vennPlot(genes_overlap_toEnrich_vennset, mymain="Overlapping genes between sample specific peaks")

genes_overlap_toEnrich_intersect_df <- as.data.frame(systemPipeR::intersectmatrix(genes_overlap_toEnrich_vennset)) %>%
  dplyr::mutate(overlaps = rowSums(.)) %>%
  tibble::rownames_to_column(var = "geneId") %>%
  #dplyr::filter(overlaps == 1) %>% not filtering for unique genes otherwise not enough significant enriching
  dplyr::select(-overlaps) %>%
  tidyr::pivot_longer(., -geneId, names_to = "sample_name", values_to = "geneOnly") %>%
  dplyr::filter(geneOnly == 1) %>%
  dplyr::group_by(sample_name) %>%
  dplyr::summarise(unique_genes = list(geneId))

unique_genes_toEnrich <- genes_overlap_toEnrich_intersect_df$unique_genes
names(unique_genes_toEnrich) <- genes_overlap_toEnrich_intersect_df$sample_name
  
lapply(unique_genes_toEnrich, length)

# enriching for GO-BP
# not a lot of significant go terms?! -> enriching first then filtering on go terms!?
perSample_GOBP_enrich_list <- purrr::map(.x = sample_names, .f = function(sample_name) {
  message("Enriching GOBP for unique genes in: ", sample_name)
  
  clusterProfiler::enrichGO(gene = unique_genes_toEnrich[[sample_name]],
                universe      = gene_universe,
                OrgDb         = org.Hs.eg.db,
                ont           = "BP",  # MF, CC, BP, ALL
                pAdjustMethod = "BH", 
                pvalueCutoff  = 1,
                qvalueCutoff  = 1,
                readable      = TRUE)
  
}) %>% setNames(sample_names)


# identify significant go terms
perSample_GOBP_enrich_df <- purrr::map(.x=perSample_GOBP_enrich_list, .f = function(enrich_res){
  as.data.frame(enrich_res) 
  
}) %>% setNames(names(perSample_GOBP_enrich_list))

perSample_GOBP_enrich_df_signif <- purrr::map(.x=perSample_GOBP_enrich_list, .f = function(enrich_res){
  enrich_res_df_signif <- as.data.frame(enrich_res) %>% 
    dplyr::filter(p.adjust < padj_perSample_GOenrich_cutoff)
  
  return(enrich_res_df_signif)
}) %>% setNames(names(perSample_GOBP_enrich_list))

perSample_GOBP_enrich_df_signif_ID <- purrr::map(.x=perSample_GOBP_enrich_df_signif, .f = function(enrich_res){
    dplyr::pull(enrich_res, ID)
}) %>% setNames(names(perSample_GOBP_enrich_df_signif))

lapply(perSample_GOBP_enrich_df_signif_ID, length)

perSample_GOBP_enrich_signif_vennset <- systemPipeR::overLapper(perSample_GOBP_enrich_df_signif_ID, type="vennsets")
perSample_GOBP_enrich_signif_intersect <- systemPipeR::intersectmatrix(systemPipeR::overLapper(perSample_GOBP_enrich_df_signif_ID, type="intersects"))
systemPipeR::vennPlot(perSample_GOBP_enrich_signif_vennset, mymain="Overlapping GOBP terms between sample specific peaks", type="ellipse")

png(filename = file.path(out_dir, "/perSample_GOBP_enrich_df_signif_ID.png"))
systemPipeR::vennPlot(perSample_GOBP_enrich_signif_vennset, mymain="Overlapping GOBP terms between sample specific peaks", type="ellipse")
dev.off()

perSample_GOBP_enrich_df_signif_collapse <- dplyr::bind_rows(perSample_GOBP_enrich_df_signif) %>%
  dplyr::select(ID, Description) %>%
  dplyr::distinct(.)

perSample_GOBP_enrich_signif_intersect_df <- as.data.frame(perSample_GOBP_enrich_signif_intersect) %>%
  dplyr::mutate(overlaps = rowSums(.)) %>%
  dplyr::mutate(patientOnly = ifelse(overlaps == 1 & Patient == 1, TRUE, FALSE)) %>%
  tibble::rownames_to_column(var="ID") %>%
  dplyr::left_join(., perSample_GOBP_enrich_df_signif_collapse, by = "ID") %>%
  dplyr::arrange(desc(patientOnly))

perSample_GOBP_enrich_signif_intersect_df_Patient <- perSample_GOBP_enrich_signif_intersect_df %>%
  dplyr::filter(overlaps == 1 & Patient == 1) %>%
  dplyr::left_join(., perSample_GOBP_enrich_df_signif$Patient, by = "ID")

perSample_GOBP_enrich_signif_intersect_df_ND01 <- perSample_GOBP_enrich_signif_intersect_df %>%
  dplyr::filter(overlaps == 1 & ND_01 == 1) %>%
  dplyr::left_join(., perSample_GOBP_enrich_df_signif$ND_01, by = "ID")

perSample_GOBP_enrich_signif_intersect_df_ND02 <- perSample_GOBP_enrich_signif_intersect_df %>%
  dplyr::filter(overlaps == 1 & ND_02 == 1) %>%
  dplyr::left_join(., perSample_GOBP_enrich_df_signif$ND_02, by = "ID")
  

# adding overlaps to significant results and saving
perSample_GOBP_enrich_df_signif_overlaps <- list(signifGO_overlaps = perSample_GOBP_enrich_signif_intersect_df,
                                                 Patient_only = perSample_GOBP_enrich_signif_intersect_df_Patient,
                                                 ND01_only = perSample_GOBP_enrich_signif_intersect_df_ND01,
                                                 ND02_only = perSample_GOBP_enrich_signif_intersect_df_ND02)

message("Saving perSample enrichment results")
save(unique_genes_toEnrich, perSample_GOBP_enrich_list, perSample_GOBP_enrich_df_signif, perSample_GOBP_enrich_signif_intersect_df, file = paste0(out_dir, "/perSample_enrichment.RData"))

openxlsx::write.xlsx(x = perSample_GOBP_enrich_df, 
                     file = paste0(out_dir, "/perSample_GOBP_enrich_all.xlsx"),
                     asTable = TRUE,
                     overwrite = TRUE) 

openxlsx::write.xlsx(x = perSample_GOBP_enrich_df_signif_overlaps, 
                     file = paste0(out_dir, "/perSample_GOBP_enrich_signif_overlaps.xlsx"),
                     asTable = TRUE,
                     overwrite = TRUE) 

```

```{r differential accesibility analysis prep, include=TRUE, eval=TRUE, cache=TRUE}
# Defining a set of non-reduntant peaks present in at least 2 samples, count reads in those peaks and use for differential accessibility analysis

if (!file.exists(paste0(out_dir, "/atacseq_metadata_counts.RData"))){
  # Counting for differential ATACseq ----
  nrToCount <- allPeaksSet_filt_nR_annot_gr # allPeaksSet_filt_nR
  #nrToCount$unique_geneID <- paste(nrToCount$geneId, as.character(seqnames(nrToCount)), IRanges::start(nrToCount), IRanges::end(nrToCount), sep = "_")
  #sum(duplicated(nrToCount$unique_geneID))  # defining unique identifier as a combination of entrezID_chr_start_end
  occurrences <- rowSums(as.data.frame(elementMetadata(nrToCount))[1:length(sample_names)])
  
  # in two and more samples!
  # - [ ] add gene names as rownames!!
  length(nrToCount)
  consensusToCount <- nrToCount[occurrences >= 2, ]  
  names(consensusToCount) <- consensusToCount$unique_geneID
  length(consensusToCount)
  
  consensusToSizeFactors <- nrToCount[occurrences == 3, ]  
  names(consensusToSizeFactors) <- consensusToSizeFactors$unique_geneID
  length(consensusToSizeFactors)
  
  # looking at annotated regions 
  consensusToCount_ND01 <- consensusToCount[consensusToCount$ND_01 == TRUE,]
  consensusToCount_ND02 <- consensusToCount[consensusToCount$ND_02 == TRUE,]
  consensusToCount_Patient <- consensusToCount[consensusToCount$Patient == TRUE,]
  # consensus_test_annot <- ChIPseeker::annotatePeak(peak = consensusToCount,
  #                                                       tssRegion=c(-3000, 3000),
  #                                                       TxDb=txdb, 
  #                                                       level = "gene",  # "transcript" or "gene"; default is transcript
  #                                                       annoDb="org.Hs.eg.db")
  
  consensusToCount_test_grlist <- GenomicRanges::GRangesList(ND_01=consensusToCount_ND01, 
                                                             ND_02=consensusToCount_ND02, 
                                                             Patient=consensusToCount_Patient)
  consensus_test_annot <- lapply(consensusToCount_test_grlist, ChIPseeker::annotatePeak, 
                                 TxDb=txdb,
                                 tssRegion=c(-3000, 3000),
                                 level = "gene",  
                                 annoDb="org.Hs.eg.db", 
                                 verbose=FALSE)
  
  consensus_test_annot_bar_plot <- ChIPseeker::plotAnnoBar(consensus_test_annot)
  consensus_test_annot_distTSS_plot <- ChIPseeker::plotDistToTSS(consensus_test_annot,
              title="Distribution of ATAC-seq peaks \nrelative to TSS")
  ggsave(consensus_test_annot_bar_plot, filename = file.path(out_dir, "/consensus_annot_bar_plot.png"))
  ggsave(consensus_test_annot_bar_plot, filename = file.path(out_dir, "/consensus_annot_bar_plot.pdf"))
  
  # consensusToCount_annot <- ChIPseeker::annotatePeak(peak = consensusToCount,
  #                                            tssRegion=c(-3000, 3000),
  #                                            TxDb=txdb, 
  #                                            level = "transcript",
  #                                            annoDb="org.Hs.eg.db")
  # 
  # consensusToCount_annot <- ChIPseeker::as.GRanges(consensusToCount_annot)
  
  # consensusToCounts is from older workshop: https://rockefelleruniversity.github.io/RU_ATAC_Workshop.html
  
  # counting reads ----
  #library(GenomicAlignments)
  #bamsToCount <- dir("~/Downloads/ATAC_Workshop/ATAC_Data/ATAC_BAM_forCounting/", full.names = TRUE, pattern = "*.\\.bam$")
  
  # to control memory we specify the number of reads to be held in memory at one time using the yield() parameter.
  bamFL <- Rsamtools::BamFileList(project_metadata$bam_files, yieldSize = 5e+06)
  
  # originally used consensusToCount
  # myCounts <- GenomicAlignments::summarizeOverlaps(features = consensusToCount_annot, 
  #                                                  reads = bamFL, 
  #                                                  singleEnd = TRUE,
  #                                                  ignore.strand = TRUE,
  #                                                  fragments = FALSE,
  #                                                  param = Rsamtools::ScanBamParam(flag = scanBamFlag(isDuplicate = FALSE)))
  counts_toSizeFactors <- GenomicAlignments::summarizeOverlaps(features = consensusToSizeFactors, 
                                                               reads = bamFL, 
                                                               singleEnd = TRUE,
                                                               ignore.strand = TRUE,
                                                               fragments = FALSE,
                                                               param = Rsamtools::ScanBamParam(flag = scanBamFlag(isDuplicate = FALSE)))
  counts_consensus <- GenomicAlignments::summarizeOverlaps(features = consensusToCount, 
                                                           reads = bamFL, 
                                                           singleEnd = TRUE,
                                                           ignore.strand = TRUE,
                                                           fragments = FALSE,
                                                           param = Rsamtools::ScanBamParam(flag = scanBamFlag(isDuplicate = FALSE)))
  
  colnames(counts_toSizeFactors) <- sample_names
  colnames(counts_consensus) <- sample_names
  
  
  # exporting consensus counts ---
  # [ ] - check how the unique_geneID was generated
  # [ ] - check on counting mode = "Union
  #AAA <- as.data.frame(rowData(counts_consensus))
  #BBB <- as.data.frame(rowRanges(counts_consensus))
  # identical(AAA, BBB) yes after seqnames, start, end, width and strand is removed
  #AAA <- as.data.frame(counts_consensus@rowRanges)
  
  counts_consensus_ranges_df <- as.data.frame(rowRanges(counts_consensus)) %>%
    dplyr::rename(ND_01_peak_detected = ND_01,
                  ND_02_peak_detected = ND_02,
                  Patient_peak_detected = Patient)
  
  # save this in a tsv - consensus_peaks_counts.tsv and generate md5sums!
  counts_consensus_counts_df <- as.data.frame(assay(counts_consensus)) %>%  # dim 21627 3
    tibble::rownames_to_column(var="unique_geneID") %>%
    dplyr::rename(ND_01_counts = ND_01,
                  ND_02_counts = ND_02,
                  Patient_counts = Patient) %>%
    dplyr::left_join(., counts_consensus_ranges_df, by = "unique_geneID")
  
  #rowRanges(myCounts)
  
  #count_data <- assay(myCounts)
  all(colnames(counts_toSizeFactors) == rownames(project_metadata))
  all(colnames(counts_consensus) == rownames(project_metadata))
  
  message("Saving metadata and counts")
  save(project_metadata, counts_consensus, counts_toSizeFactors, nrToCount, blacklist, file = paste0(out_dir, "/atacseq_metadata_counts.RData"))
} else {
  message("Loading metadata and counts")
  load(file = paste0(out_dir, "/atacseq_metadata_counts.RData"))
}

# compare to Florian's approach
# counts <- summarizeReads(peaks, dA$sample_name, dA$reads_file, useDuplicates=useDuplicates)
# summarizeReads runs:
# so <- as.data.table(assay(summarizeOverlaps(features = regs, 
#                                             reads = BamFileList(file.paths[i], 
#                                                                 yieldSize = 5000000), 
#                                             ignore.strand = TRUE, 
#                                             singleEnd = TRUE, 
#                                             fragments = FALSE, 
#                                             param = ScanBamParam(flag = scanBamFlag(isDuplicate = useDuplicates)))))
# counts[, rpm:=count / lib$dt2namedVec(counts[,sum(count),by=sampleName],"sampleName")[sampleName] * 1000000]
# counts

```

```{r differential accesibility analysis run, include=TRUE, eval=TRUE, cache=TRUE}

# DESeq2 analysis
#load("data/myCounts.RData")
# metaData <- data.frame(Group, row.names = colnames(myCounts))


if (!file.exists(paste0(out_dir, "/dds_objects.RData"))){
  # pre-calculating size factors
  atacDDS_toSizeFactors <- DESeq2::DESeqDataSetFromMatrix(countData = assay(counts_toSizeFactors), 
                                                          colData = project_metadata, 
                                                          design = ~sample_group, 
                                                          rowRanges = rowRanges(counts_toSizeFactors))  # rowRanges(myCounts) == 
  
  atacDDS_withoutControls <- DESeq2::DESeqDataSetFromMatrix(countData = assay(counts_consensus), 
                                                            colData = project_metadata, 
                                                            design = ~sample_group, 
                                                            rowRanges = rowRanges(counts_consensus))  # rowRanges(myCounts) == consensusToCount
  
  atacDDS <- DESeq2::DESeqDataSetFromMatrix(countData = assay(counts_consensus), 
                                            colData = project_metadata, 
                                            design = ~sample_group, 
                                            rowRanges = rowRanges(counts_consensus))  # rowRanges(myCounts) == consensusToCount
  
  atacDDS_toSizeFactors <- DESeq2::estimateSizeFactors(atacDDS_toSizeFactors)
  atacDDS_withoutControls <- DESeq2::estimateSizeFactors(atacDDS_withoutControls)
  
  atacDDS_toSizeFactors_sf <- DESeq2::sizeFactors(atacDDS_toSizeFactors)
  atacDDS_withoutControls_sf <- DESeq2::sizeFactors(atacDDS_withoutControls)
  
  # frozen geomMeans? (but would need all of the gens)
  # rather use controlGenes
  control_genes <- rownames(atacDDS_withoutControls) %in% rownames(atacDDS_toSizeFactors)
  table(control_genes)
  atacDDS <- DESeq2::estimateSizeFactors(atacDDS, controlGenes = control_genes)
  atacDDS_sf <- DESeq2::sizeFactors(atacDDS)
  
  # comparing size factors
  sf_comparison_list <- list(controls_sf = atacDDS_toSizeFactors_sf,
                             consensus_noControls = atacDDS_withoutControls_sf,
                             consensus_controlsCorrected = atacDDS_sf)
  sf_comparison <- dplyr::bind_rows(sf_comparison_list, .id="sf_origin")
  
  # different length :D
  # geoMeans <- exp(rowMeans(log(counts(atacDDS_toSizeFactors))))
  # dds_test <- estimateSizeFactors(atacDDS,geoMeans=geoMeans)
  # sizeFactors(dds)
  
  # plot before and after normalization and differences in using all overlapping size factors?!
  atacDDS_withoutControls_rawCounts <- DESeq2::counts(object = atacDDS_withoutControls, normalized = FALSE)
  atacDDS_withoutControls_normCounts <- DESeq2::counts(object = atacDDS_withoutControls, normalized = TRUE)
  atacDDS_rawCounts <- DESeq2::counts(object = atacDDS, normalized = FALSE)
  atacDDS_normCounts <- DESeq2::counts(object = atacDDS, normalized = TRUE)
  
  atacDDS_withoutControls_rawCounts_df <- as.data.frame(atacDDS_withoutControls_rawCounts) %>%
    tibble::rownames_to_column(var = "unique_geneID") %>%
    tidyr::pivot_longer(., -unique_geneID, names_to = "sample_name", values_to = "counts") %>%
    dplyr::mutate(count_type = "raw_counts",
                  sf_origin = "consensus_noControls")
  
  atacDDS_withoutControls_normCounts_df <- as.data.frame(atacDDS_withoutControls_normCounts) %>%
    tibble::rownames_to_column(var = "unique_geneID") %>%
    tidyr::pivot_longer(., -unique_geneID, names_to = "sample_name", values_to = "counts") %>%
    dplyr::mutate(count_type = "norm_counts",
                  sf_origin = "consensus_noControls")
  
  atacDDS_rawCounts_df <- as.data.frame(atacDDS_rawCounts) %>%
    tibble::rownames_to_column(var = "unique_geneID") %>%
    tidyr::pivot_longer(., -unique_geneID, names_to = "sample_name", values_to = "counts") %>%
    dplyr::mutate(count_type = "raw_counts",
                  sf_origin = "consensus_controlsCorrected")
  
  atacDDS_normCounts_df <- as.data.frame(atacDDS_normCounts) %>%
    tibble::rownames_to_column(var = "unique_geneID") %>%
    tidyr::pivot_longer(., -unique_geneID, names_to = "sample_name", values_to = "counts") %>%
    dplyr::mutate(count_type = "norm_counts",
                  sf_origin = "consensus_controlsCorrected")
  
  sf_comparison_counts_df <- dplyr::bind_rows(atacDDS_withoutControls_rawCounts_df,
                                              atacDDS_withoutControls_normCounts_df,
                                              atacDDS_rawCounts_df,
                                              atacDDS_normCounts_df) %>%
    dplyr::mutate(count_type = factor(count_type, levels = c("raw_counts", "norm_counts")),
                  sf_origin = factor(sf_origin, levels = c("consensus_noControls", "consensus_controlsCorrected")))
  
  sf_comparison_counts_box_plot <- ggplot(data = sf_comparison_counts_df, aes(x=count_type, y=log2(counts + 1), fill=sample_name)) + 
    geom_boxplot() + 
    facet_wrap(~sf_origin) +
    theme_bw()
  
  sf_comparison_counts_dens_plot <- ggplot(data = sf_comparison_counts_df, aes(x=log2(counts + 1), fill=sample_name)) + 
    geom_density(alpha = 0.6) + 
    facet_wrap(~count_type + sf_origin) +
    theme_bw()
  
  ggsave(sf_comparison_counts_box_plot, filename = file.path(out_dir, "/sf_comparison_counts_box_plot.png"))
  ggsave(sf_comparison_counts_dens_plot, filename = file.path(out_dir, "/sf_comparison_counts_dens_plot.png"))
  
  # betaPrior=FALSE is now by default and should be followed by lfcShrink
  # however, setting here betaPrior=T; also consistent with similar setting as Florian: dds <- DESeq(dds, test="Wald", fitType="local", betaPrior=T)
  
  # further compare
  #atacDDS <- DESeq2::DESeq(atacDDS, test="Wald", fitType="local", betaPrior=T)
  
  # here they also run withut betaPrior? check version!
  # https://github.com/Zhang-lab/ATACseq_benchmarking/blob/master/simulated_ATAC_tests_DESeq2.R
  # https://support.bioconductor.org/p/95436/
  # https://support.bioconductor.org/p/68772/
  # https://bioinformatics.stackexchange.com/questions/10837/loss-and-gain-of-region-in-atac-seq
  #https://support.bioconductor.org/p/103348/
  # also setting betaPrior=TRUE since no shrinking is done aferwards; https://support.bioconductor.org/p/118257/
  # make sure it uses pre-existing size factors!
  atacDDS_withoutControls <- DESeq2::DESeq(atacDDS_withoutControls, test="Wald", fitType="local", betaPrior=TRUE)
  atacDDS <- DESeq2::DESeq(atacDDS, test="Wald", fitType="local", betaPrior=TRUE)  # set local as in Diffbind; see manual and 
  
  # what dispersion is expected for ATAC-seq?]
  # par(mfrow=c(1,2)) 
  # DESeq2::plotDispEsts(atacDDS_withoutControls)
  # DESeq2::plotDispEsts(atacDDS)
  # dev.off()
  
  atac_rlog <- DESeq2::rlog(atacDDS)
  atac_rlog_ranges <- rowRanges(atac_rlog)
  atac_rlog_counts <- assay(atac_rlog)  # use for heatmaps
  atac_pca <- DESeq2::plotPCA(atac_rlog, intgroup = "sample_group", ntop = nrow(atac_rlog)) + theme_bw()
  
  message("Saving dds objects")
  save(atacDDS, atacDDS_withoutControls, atacDDS_toSizeFactors, file = paste0(out_dir, "/dds_objects.RData"))
} else {
  
  message("Loading dds objects")
  load(file = paste0(out_dir, "/dds_objects.RData"))
  
  atac_rlog <- DESeq2::rlog(atacDDS)
  atac_rlog_ranges <- rowRanges(atac_rlog)
  atac_rlog_counts <- assay(atac_rlog)
}

# tsne and umap!
#install.packages("umap")
#atac_pca <- umap::umap(assay(atac_rlog))


# With the new DESeq2 object we can now test for any differences in ATACseq signal between groups.

#DESeq2::resultsNames(atacDDS)

# extracting differential accessibility results ----
# contrasts
# patient_vs_NDs c("sample_group", "Patient", "ND")

de_comparisons <- list(patient_vs_NDs = c("sample_group", "Patient", "ND"))

#future::plan(future::multisession, workers = 4)

de_results <- purrr::map(.x = names(de_comparisons), .f = function(comparison_name){
  # extract DE results
  #   run annotation
  # extract significant - UP, DOWN
  #   run annotation
  #   run GO enrichment
  
  message(paste0("Processing comparison: ", comparison_name))
  
  # extract DE results
  #   run annotation
  temp_contrast <- de_comparisons[[comparison_name]]
  de_results_gr <- DESeq2::results(atacDDS, contrast = temp_contrast, format = "GRanges")
  de_results_gr <- de_results_gr[order(de_results_gr$pvalue)]  # order based on p-value
  
  return(list(de_results_gr = de_results_gr))
  
}) %>% setNames(names(de_comparisons))


# patient_vs_NDs ----
# annotating DESeq2 results
# selecting significant results
# - [ ] include in the above map function!?, but rewrite function outside and properly define inputs?!

patient_vs_NDs_results_dir <- file.path(out_dir, "patient_vs_NDs_results")
dir.create(patient_vs_NDs_results_dir, showWarnings = TRUE)

# annotating DESeq2 results ----
de_results_gr <- de_results$patient_vs_NDs$de_results_gr
de_results_df <- as.data.frame(de_results_gr) %>%
  tibble::rownames_to_column(var="unique_geneID") %>%
  #dplyr::mutate(geneId = stringr::str_split_fixed(unique_geneID, pattern = "_", 4)[,1]) %>%
  dplyr::left_join(., dplyr::select(allPeaksSet_filt_nR_annot_df, -seqnames, -start, -end, -width, -strand), by = "unique_geneID")  # annotating

# selecting signaficang results ----
# de_results_df_filt <- de_results_df %>%
#   dplyr::filter(!is.na(padj))

# padj significance
de_results_df_filt_signifPadj <- de_results_df %>%
  dplyr::filter(!is.na(padj) & padj < padj_cutoff)
quantile(de_results_df_filt_signifPadj$log2FoldChange)  # these are all down!
  
de_results_df_filt_signifPadj_UP_DOWN <- de_results_df_filt_signifPadj %>%
  dplyr::mutate(FC_direction = ifelse(log2FoldChange < 0, "DOWN", "UP"))
table(de_results_df_filt_signifPadj_UP_DOWN$FC_direction)

# !!! see also below, but using these it defines promoter regions that were previously annotated as more than 100kb from TSS
# ChIPSeeker wrong at calculating TSS distance?
#toOverLap <- GenomicFeatures::promoters(txdb, promoter_dist, promoter_dist)  
# potentially increase to 3000 as in http://bioconductor.org/packages/devel/bioc/vignettes/ChIPseeker/inst/doc/ChIPseeker.html#peak-heatmaps
# - [ ] However, above still gives some non-promoter sequences; filter further before enrichment?
# - [ ] see priorities in ChIPseeker annotation

# !!!  de_results_gr %over% toOverLap produces also more than 1000kb window?! why?
# rely on annotation and 
# de_results_df_filt_signifLog2Promoters <- de_results_gr[(!is.na(de_results_gr$padj) & 
#                                                    abs(de_results_gr$log2FoldChange) > log2FC_cutoff) & de_results_gr %over% toOverLap, ]
# de_results_df_filt_signifLog2Promoters <- de_results_gr[(!is.na(de_results_gr$padj) & 
#                                                    abs(de_results_gr$log2FoldChange) > log2FC_cutoff) & (abs(distanceToTSS) <= promoter_dist),]
# de_results_df_filt_signifLog2Promoters_df <- as.data.frame(de_results_df_filt_signifLog2Promoters) %>%
#   tibble::rownames_to_column(var="unique_geneID") %>%
#   #dplyr::mutate(geneId = stringr::str_split_fixed(unique_geneID, pattern = "_", 4)[,1]) %>%
#   dplyr::left_join(., dplyr::select(allPeaksSet_filt_nR_annot_df, -seqnames, -start, -end, -width, -strand), by = "unique_geneID")  # annotating

# sum(abs(de_results_df$log2FoldChange) > log2FC_cutoff)
# sum(abs(de_results_df$distanceToTSS) <= promoter_dist)
# sum(abs(de_results_df$log2FoldChange) > log2FC_cutoff & abs(de_results_df$distanceToTSS) <= promoter_dist)

de_results_df_filt_signifLog2Promoters_df <- de_results_df %>%
  dplyr::filter((abs(log2FoldChange) > log2FC_cutoff) & (abs(distanceToTSS) <= promoter_dist))

de_results_df_filt_signifLog2Promoters_df_UP_DOWN <- de_results_df_filt_signifLog2Promoters_df %>%
  dplyr::mutate(FC_direction = ifelse(log2FoldChange < 0, "DOWN", "UP"))
table(de_results_df_filt_signifLog2Promoters_df_UP_DOWN$FC_direction)

# quantile(de_results_df_filt_signifLog2Promoters_df$log2FoldChange) 
# quantile(de_results_df_filt_signifLog2Promoters_df$distanceToTSS) 

# renaming duplicates
de_results_df_filt_signifLog2Promoters_df_dupl <- de_results_df_filt_signifLog2Promoters_df[duplicated(de_results_df_filt_signifLog2Promoters_df$SYMBOL) | duplicated(de_results_df_filt_signifLog2Promoters_df$SYMBOL, fromLast=TRUE),]

de_results_df_filt_signifLog2Promoters_df_duplFix <- de_results_df_filt_signifLog2Promoters_df %>%
  dplyr::mutate(SYMBOL = ifelse(SYMBOL %in% de_results_df_filt_signifLog2Promoters_df_dupl$SYMBOL, paste(SYMBOL, seqnames, start, end, sep = "_"), SYMBOL))

# for heatmap ----
# mostly down
de_results_df_filt_signifPadj_forHeatmap <- de_results_df_filt_signifPadj %>%
  dplyr::select(unique_geneID, SYMBOL)
# check for duplicates in gene symbols
#sum(duplicated(de_results_df_filt_signifPadj_forHeatmap$SYMBOL))
  
atac_rlog_counts_forHeatmap_signifPadj <- as.data.frame(atac_rlog_counts) %>%
  tibble::rownames_to_column(var="unique_geneID") %>%
  dplyr::right_join(., de_results_df_filt_signifPadj_forHeatmap, by = "unique_geneID") %>%
  dplyr::select(-unique_geneID) %>%
  tibble::column_to_rownames("SYMBOL")
  
annotCol_forHeatmap <- project_metadata %>%
  dplyr::select(sample_name, condition) %>%
  tibble::column_to_rownames(var="sample_name")

annotRow_forHeatmap <- de_results_df_filt_signifPadj %>%
  dplyr::select(SYMBOL, annotation) %>%
  dplyr::mutate(annotation = gsub(pattern = "(Exon|Intron)( \\(.+)", replacement = "\\1", annotation)) %>%
  tibble::column_to_rownames(var="SYMBOL")

pheatmap::pheatmap(atac_rlog_counts_forHeatmap_signifPadj, 
                   scale = "row", 
                   cluster_cols = FALSE,
                   annotation_col = annotCol_forHeatmap,
                   annotation_row = annotRow_forHeatmap)

pheatmap::pheatmap(atac_rlog_counts_forHeatmap_signifPadj, 
                   scale = "row", 
                   cluster_cols = FALSE,
                   annotation_col = annotCol_forHeatmap,
                   annotation_row = annotRow_forHeatmap,
                  filename = file.path(patient_vs_NDs_results_dir, "de_results_heatmap_signifPadj.pdf"))

pheatmap::pheatmap(atac_rlog_counts_forHeatmap_signifPadj, 
                   scale = "row", 
                   cluster_cols = FALSE,
                   annotation_col = annotCol_forHeatmap,
                   annotation_row = annotRow_forHeatmap,
                  filename = file.path(patient_vs_NDs_results_dir, "de_results_heatmap_signifPadj.png"))

# for logFC significance
de_results_df_filt_signifLog2Promoters_forHeatmap <- de_results_df_filt_signifLog2Promoters_df_duplFix %>%
  dplyr::select(unique_geneID, SYMBOL)
# check for duplicates in gene symbols
sum(duplicated(de_results_df_filt_signifLog2Promoters_forHeatmap$SYMBOL))
  
atac_rlog_counts_forHeatmap_signifLog2Promoters <- as.data.frame(atac_rlog_counts) %>%
  tibble::rownames_to_column(var="unique_geneID") %>%
  dplyr::right_join(., de_results_df_filt_signifLog2Promoters_forHeatmap, by = "unique_geneID") %>%
  dplyr::select(-unique_geneID) %>%
  tibble::column_to_rownames("SYMBOL")
  
annotRow_forHeatmap <- de_results_df_filt_signifLog2Promoters_df_duplFix %>%
  dplyr::select(SYMBOL, annotation) %>%
  dplyr::mutate(annotation = gsub(pattern = "(Exon|Intron)( \\(.+)", replacement = "\\1", annotation)) %>%
  tibble::column_to_rownames(var="SYMBOL")

pheatmap::pheatmap(atac_rlog_counts_forHeatmap_signifLog2Promoters, 
                   scale = "row", 
                   cluster_cols = FALSE,
                   annotation_col = annotCol_forHeatmap,
                   annotation_row = annotRow_forHeatmap,
                   fontsize_row = 4)  # fontsize_row = 10

pheatmap::pheatmap(atac_rlog_counts_forHeatmap_signifLog2Promoters, 
                   scale = "row", 
                   cluster_cols = FALSE,
                   annotation_col = annotCol_forHeatmap,
                   annotation_row = annotRow_forHeatmap,
                   fontsize_row = 4,
                   filename = file.path(patient_vs_NDs_results_dir, "de_results_heatmap_signifLog2Promoters.pdf"))

pheatmap::pheatmap(atac_rlog_counts_forHeatmap_signifLog2Promoters, 
                   scale = "row", 
                   cluster_cols = FALSE,
                   annotation_col = annotCol_forHeatmap,
                   annotation_row = annotRow_forHeatmap,
                   fontsize_row = 4,
                  filename = file.path(patient_vs_NDs_results_dir, "de_results_heatmap_signifLog2Promoters.png"))

# pub quality heatmap ----
# for the downregulated: HDAC7, NT5E, IL7R, CCR2, LDOC1, CRTAM, IL2, ITGAX, TESPA1, TRAF2IP2, STAT5A, TCF7, IFNG, IKZF2, CD44, CAP70, RANGAP1, LY9, NFAT5, CDK6, CD7 and VAV1
# for the upregulated: FOXO6, KLF16, SUB1, IL7, TGFB1, HEXD, NELFCD, CSNK1G2, MAP2K7, PPP1R15A and TCF25
highlight_genes <- c("HDAC7", "NT5E", "IL7R", "CCR2", "LDOC1", "CRTAM", "IL2", "ITGAX", "TESPA1", "TRAF3IP2", "STAT5A", "TCF7", "IFNG", "IKZF2", "CD44", "ZAP70", "RANGAP1", "LY9", "NFAT5", "CDK6", "CD7", "VAV1", "FOXO6", "KLF16", "SUB1", "IL7", "TGFB1", "HEXD", "NELFCD", "CSNK1G2", "MAP2K7", "PPP1R15A", "TCF25")
# length(highlight_genes) 33 genes!

### Heatmap
# nice hack from https://stackoverflow.com/questions/52599180/partial-row-labels-heatmap-r

# heat refers to the original heatmap produced from the pheatmap() function
# kept.labels should be a vector of labels you wish to show
# repel.degree is a number in the range [0, 1], controlling how much the
# labels are spread out from one another
add.flag <- function(pheatmap,
                     kept.labels,
                     repel.degree,
                     hiden.labels.character="") {
  
  # repel.degree = number within [0, 1], which controls how much 
  #                space to allocate for repelling labels.
  ## repel.degree = 0: spread out labels over existing range of kept labels
  ## repel.degree = 1: spread out labels over the full y-axis
  # PR: hiden.labels.character - character to hide labels; e.g. if need to add spacing?!
  
  heatmap <- pheatmap$gtable
  
  new.label <- heatmap$grobs[[which(heatmap$layout$name == "row_names")]] 
  
  # keep only labels in kept.labels, replace the rest with ""
  # new.label$label <- ifelse(new.label$label %in% kept.labels, 
  #                           new.label$label, "")
    new.label$label <- ifelse(new.label$label %in% kept.labels, 
                            new.label$label, hiden.labels.character)
  
  # calculate evenly spaced out y-axis positions
  repelled.y <- function(d, d.select, k = repel.degree){
    # d = vector of distances for labels
    # d.select = vector of T/F for which labels are significant
    
    # recursive function to get current label positions
    # (note the unit is "npc" for all components of each distance)
    strip.npc <- function(dd){
      if(!"unit.arithmetic" %in% class(dd)) {
        return(as.numeric(dd))
      }
      
      d1 <- strip.npc(dd$arg1)
      d2 <- strip.npc(dd$arg2)
      fn <- dd$fname
      return(lazyeval::lazy_eval(paste(d1, fn, d2)))
    }
    
    full.range <- sapply(seq_along(d), function(i) strip.npc(d[i]))
    selected.range <- sapply(seq_along(d[d.select]), function(i) strip.npc(d[d.select][i]))
    
    return(unit(seq(from = max(selected.range) + k*(max(full.range) - max(selected.range)),
                    to = min(selected.range) - k*(min(selected.range) - min(full.range)), 
                    length.out = sum(d.select)), 
                "npc"))
  }
  new.y.positions <- repelled.y(new.label$y,
                                d.select = new.label$label != hiden.labels.character)
  new.flag <- segmentsGrob(x0 = new.label$x,
                           x1 = new.label$x + unit(0.15, "npc"),
                           y0 = new.label$y[new.label$label != hiden.labels.character],
                           y1 = new.y.positions)
  
  # shift position for selected labels
  new.label$x <- new.label$x + unit(0.2, "npc")
  new.label$y[new.label$label != hiden.labels.character] <- new.y.positions
  
  # add flag to heatmap
  heatmap <- gtable::gtable_add_grob(x = heatmap,
                                     grobs = new.flag,
                                     t = 4, 
                                     l = 4
  )
  
  # replace label positions in heatmap
  heatmap$grobs[[which(heatmap$layout$name == "row_names")]] <- new.label
  
  # plot result
  grid.newpage()
  grid.draw(heatmap)
  
  # return a copy of the heatmap invisibly
  invisible(heatmap)
}


annotCol_forHeatmap <- project_metadata %>%
  dplyr::select(sample_name, condition) %>%
  dplyr::rename(genotype = condition) %>%
  dplyr::mutate(genotype = if_else(genotype == "IKZF2-WT", "WT", "I325V-Hom")) %>%
  dplyr::mutate(bio_rep = sample_name) %>%
  tibble::column_to_rownames(var="sample_name")

# annotRow_forHeatmap <- de_results_df_filt_signifPadj %>%
#   dplyr::select(SYMBOL, annotation) %>%
#   dplyr::mutate(annotation = gsub(pattern = "(Exon|Intron)( \\(.+)", replacement = "\\1", annotation)) %>%
#   tibble::column_to_rownames(var="SYMBOL")

#scales::show_col(c("#d9d9d9", "#969696", "#fd8d3c"))

annotCol_forHeatmap_colors <- list(genotype = c(  WT="#525252", `I325V-Hom` = "#fc4e2a"),
                                   bio_rep = c(ND_01 = "#d9d9d9", ND_02= "#969696", Patient = "#fd8d3c"))

# - [] large gap between legend and heatmap - due to long gene names!
# remove row labels during plotting
row_labels <- rownames(atac_rlog_counts_forHeatmap_signifLog2Promoters)
#nchar(row_labels)
row_labels <- ifelse(row_labels %in% highlight_genes, row_labels, stringr::str_pad("", width = 25, side = "both")) # 14 spaces - small hack to keep gaps after repel
#nchar(row_labels)
# small hack to add spacing between legend and heatmap after 

signifLog2Promoters_heatmap <-  pheatmap::pheatmap(as.matrix(atac_rlog_counts_forHeatmap_signifLog2Promoters),
                                                   color = colorRampPalette(rev(brewer.pal(7, "PiYG")))(100),
                                                   scale = "row",
                                                   #gaps_col = ph_col_annot%>% arrange(state)%$% table(state) %>% cumsum,
                                                   #gaps_row = ph_genes$clust %>% table() %>% cumsum,
                                                   cluster_cols = FALSE,
                                                   cluster_rows = TRUE,
                                                   show_colnames = FALSE,
                                                   show_rownames = TRUE,
                                                   annotation_col = annotCol_forHeatmap,
                                                   #annotation_row = ph_row_annot,
                                                   #annotation_legend = FALSE,
                                                   annotation_colors = annotCol_forHeatmap_colors,  # add manual annotation corresponding to samples
                                                   labels_row = row_labels,
                                                   fontsize_row = 9,
                                                   fontsize = 9,
                                                   #cellheight = 9,
                                                   main = "Significantly differentially accessible regions")

signifLog2Promoters_heatmap_upd <- add.flag(signifLog2Promoters_heatmap,
                                            kept.labels = highlight_genes,
                                            repel.degree = 0.2,
                                            hiden.labels.character = "") # 14 spaces? - small hack to keep gaps after repel
  
pdf(file.path(patient_vs_NDs_results_dir, "dar_signifLog2Promoters_heatmap.pdf"))
grid.draw(signifLog2Promoters_heatmap_upd)
dev.off()
  
# ### Get order of genes after clustering
# genesInHeatOrder_v <- heat$tree_row$labels[heat$tree_row$order]
# whichSigInHeatOrder_v <- which(genesInHeatOrder_v %in% sigGenes_v)
# whichSigInHeatOrderLabels_v <- genesInHeatOrder_v[whichSigInHeatOrder_v]
# 
# sigY <- 1 - (0.02 * whichSigInHeatOrder_v)
# 
# ### Change title
# whichMainGrob_v <- which(heat$gtable$layout$name == "main")
# heat$gtable$grobs[[whichMainGrob_v]] <- textGrob(label = newMain_v, 
#                                                  gp = gpar(fontsize = 16))
# 
# ### Remove rows
# whichRowGrob_v <- which(heat$gtable$layout$name == "row_names")
# heat$gtable$grobs[[whichRowGrob_v]] <- textGrob(label = whichSigInHeatOrderLabels_v,
#                                                 y = sigY,
#                                                 vjust = 1)
# grid.newpage()
# grid.draw(heat)

# plotting heatmap from scratch
# library("ComplexHeatmap")
# ha = rowAnnotation(foo = anno_mark(at = c(1:4, 20, 60, 97:100), labels = month.name[1:10]))
# Heatmap(m, name = "mat", cluster_rows = FALSE, right_annotation = ha,
#         row_names_side = "left", row_names_gp = gpar(fontsize = 4))
# Heatmap(m, name = "mat", cluster_rows = FALSE, right_annotation = ha,
#         row_names_side = "left", row_names_gp = gpar(fontsize = 4), row_km = 4)

# also add filtering criteria!
message("Saving DE results")
save(de_results, de_results_df, de_results_df_filt_signifPadj, de_results_df_filt_signifLog2Promoters_df, file = file.path(patient_vs_NDs_results_dir, "de_results_all.RData"))

de_filters <- data.frame(de_results_signifPadj = paste0("!is.na(padj) & padj < ", padj_cutoff),
                         de_results_signifLog2Promoters = paste0("(abs(log2FoldChange) > ", log2FC_cutoff,") & (abs(distanceToTSS) <= ", promoter_dist,"); distanceToTSS - window of ", promoter_dist," around TSS"))

de_results_df_toSave <- list(de_results = de_results_df,
                             de_results_signifPadj = de_results_df_filt_signifPadj,
                             de_results_signifLog2Promoters = de_results_df_filt_signifLog2Promoters_df,
                             applied_filters = de_filters)
openxlsx::write.xlsx(x = de_results_df_toSave, 
                     file = paste0(patient_vs_NDs_results_dir, "/de_results_patient_vs_NDs_results.xlsx"),
                     asTable = TRUE,
                     overwrite = TRUE) 

# de_results_df_filt_forRanking <- de_results_df_filt %>%
#   dplyr::select(geneId, log2FoldChange, distanceToTSS) %>%
#   dplyr::group_by(geneId) %>%
#   dplyr::summarise(log2FoldChange = log2FoldChange[abs(distanceToTSS) == min(abs(distanceToTSS))]) %>%  # min dist to TSS
#   dplyr::arrange(desc(log2FoldChange))
#   #dplyr::summarise(log2FoldChange = log2FoldChange[abs(log2FoldChange) == max(abs(log2FoldChange))])  # max log2FC
#   #dplyr::summarise(log2FoldChange = log2FoldChange[abs(log2FoldChange) == max(abs(log2FoldChange) & abs(distanceToTSS) == min(abs(distanceToTSS)))]) 

# for ranked list keep smallest distance to TSS and/or largest log2FC? - abs() for both
# ranked_list <- de_results_df_filt_forRanking$log2FoldChange
# names(ranked_list)<- de_results_df_filt_forRanking$geneId

# - [ ] merge with previous annotation! 
# - [ ] GSEA: rank based on log2FC; GOBP,GOCC,GOMF; Transcription factors; GSEA would be better, but how to resolve duplicated geneId (based on log2FC and/or distance to TSS?)
# - [ ] motif analysis (or not)
# - [ ] finish previous unique peaks analysis

#   run annotation
# extract significant - UP, DOWN
#   run annotation
#   run GO enrichment
# significant based on log2FC

enrich_GOterms <- c(GOBP="BP", GOMF="MF", GOCC="CC")

de_results_df_filt_signifPadj_UP <- de_results_df_filt_signifPadj %>%
  dplyr::filter(log2FoldChange > 0)
de_results_df_filt_signifPadj_DOWN <- de_results_df_filt_signifPadj %>%
  dplyr::filter(log2FoldChange < 0)
  
message("de_results_signif_annot_df all: ", nrow(de_results_df_filt_signifPadj))  
message("de_results_signif_annot_df_UP genes: ", nrow(de_results_df_filt_signifPadj_UP))
message("de_results_signif_annot_df_DOWN genes: ", nrow(de_results_df_filt_signifPadj_DOWN))

signifPadj_genesToEnrich <- list(all=unique(de_results_df_filt_signifPadj$geneId),
                                          up=unique(de_results_df_filt_signifPadj_UP$geneId),
                                          down=unique(de_results_df_filt_signifPadj_DOWN$geneId))

signifPadj_goEnrichment <- purrr::map(.x = names(signifPadj_genesToEnrich), .f = function(gene_set){
  message("Enriching genes ", gene_set)
  
  goEnrichment <- purrr::map(.x = names(enrich_GOterms), .f = function(GO_name){
    message("Enriching for ", GO_name)
    
    clusterProfiler::enrichGO(gene = signifPadj_genesToEnrich[[gene_set]],
                              universe      = gene_universe,
                              OrgDb         = org.Hs.eg.db,
                              ont           = enrich_GOterms[[GO_name]],  # MF, CC, BP, ALL
                              pAdjustMethod = "BH", 
                              pvalueCutoff  = 1,
                              qvalueCutoff  = 1,
                              readable      = TRUE)
    
  }) %>% setNames(names(enrich_GOterms))
  
  return(goEnrichment)
  
}) %>% setNames(names(signifPadj_genesToEnrich))

# 
# signifPadj_DOWN_goEnrichment <- purrr::map(.x = names(enrich_GOterms), .f = function(GO_name){
#   message("Enriching for ", GO_name)
#   
#   clusterProfiler::enrichGO(gene = de_results_df_filt_signifPadj_DOWN$geneId,
#                             universe      = gene_universe,
#                             OrgDb         = org.Hs.eg.db,
#                             ont           = enrich_GOterms[[GO_name]],  # MF, CC, BP, ALL
#                             pAdjustMethod = "BH", 
#                             pvalueCutoff  = 1,
#                             qvalueCutoff  = 1,
#                             readable      = TRUE)
#   
# }) %>% setNames(names(enrich_GOterms))

#signifPadj_DOWN_goEnrichment_df <- purrr::map(.x = signifPadj_DOWN_goEnrichment, .f = as.data.frame) %>% setNames(names(signifPadj_DOWN_goEnrichment))
signifPadj_ALL_goEnrichment_df <- purrr::map(.x = signifPadj_goEnrichment$all, .f = as.data.frame) %>% setNames(names(signifPadj_goEnrichment$all))
signifPadj_UP_goEnrichment_df <- purrr::map(.x = signifPadj_goEnrichment$up, .f = as.data.frame) %>% setNames(names(signifPadj_goEnrichment$up))
signifPadj_DOWN_goEnrichment_df <- purrr::map(.x = signifPadj_goEnrichment$down, .f = as.data.frame) %>% setNames(names(signifPadj_goEnrichment$down))
 
openxlsx::write.xlsx(x = signifPadj_ALL_goEnrichment_df, 
                     file = paste0(patient_vs_NDs_results_dir, "/de_results_patient_vs_NDs_signifPadj_ALL_GOenrich.xlsx"),
                     asTable = TRUE,
                     overwrite = TRUE) 

openxlsx::write.xlsx(x = signifPadj_DOWN_goEnrichment_df, 
                     file = paste0(patient_vs_NDs_results_dir, "/de_results_patient_vs_NDs_signifPadj_DOWN_GOenrich.xlsx"),
                     asTable = TRUE,
                     overwrite = TRUE) 

# on log2FC ----
de_results_df_filt_signifLog2Promoters_UP <- de_results_df_filt_signifLog2Promoters_df %>%
  dplyr::filter(log2FoldChange > 0)
de_results_df_filt_signifLog2Promoters_DOWN <- de_results_df_filt_signifLog2Promoters_df %>%
  dplyr::filter(log2FoldChange < 0)

message("de_results_signif_annot_df all: ", nrow(de_results_df_filt_signifLog2Promoters_df))  
message("de_results_signif_annot_df_UP genes: ", nrow(de_results_df_filt_signifLog2Promoters_UP))
message("de_results_signif_annot_df_DOWN genes: ", nrow(de_results_df_filt_signifLog2Promoters_DOWN))

signifLog2Promoters_genesToEnrich <- list(all=unique(de_results_df_filt_signifLog2Promoters_df$geneId),
                                          up=unique(de_results_df_filt_signifLog2Promoters_UP$geneId),
                                          down=unique(de_results_df_filt_signifLog2Promoters_DOWN$geneId))

signifLog2Promoters_goEnrichment <- purrr::map(.x = names(signifLog2Promoters_genesToEnrich), .f = function(gene_set){
  message("Enriching genes ", gene_set)
  
  goEnrichment <- purrr::map(.x = names(enrich_GOterms), .f = function(GO_name){
    message("Enriching for ", GO_name)
    
    clusterProfiler::enrichGO(gene = signifLog2Promoters_genesToEnrich[[gene_set]],
                              universe      = gene_universe,
                              OrgDb         = org.Hs.eg.db,
                              ont           = enrich_GOterms[[GO_name]],  # MF, CC, BP, ALL
                              pAdjustMethod = "BH", 
                              pvalueCutoff  = 1,
                              qvalueCutoff  = 1,
                              readable      = TRUE)
    
  }) %>% setNames(names(enrich_GOterms))
  
  return(goEnrichment)
  
}) %>% setNames(names(signifLog2Promoters_genesToEnrich))

# - [ ] make into a function so it is less error-prone 
signifLog2Promoters_ALL_goEnrichment_df <- purrr::map(.x = signifLog2Promoters_goEnrichment$all, .f = as.data.frame) %>% setNames(names(signifLog2Promoters_goEnrichment$all))

signifLog2Promoters_UP_goEnrichment_df <- purrr::map(.x = signifLog2Promoters_goEnrichment$up, .f = as.data.frame) %>% setNames(names(signifLog2Promoters_goEnrichment$up))

signifLog2Promoters_DOWN_goEnrichment_df <- purrr::map(.x = signifLog2Promoters_goEnrichment$down, .f = as.data.frame) %>% setNames(names(signifLog2Promoters_goEnrichment$down))

lapply(signifLog2Promoters_ALL_goEnrichment_df, length)
lapply(signifLog2Promoters_UP_goEnrichment_df, length)
lapply(signifLog2Promoters_DOWN_goEnrichment_df, length)

openxlsx::write.xlsx(x = signifLog2Promoters_ALL_goEnrichment_df, 
                     file = paste0(patient_vs_NDs_results_dir, "/de_results_patient_vs_NDs_signifLog2Promoters_ALL_GOenrich.xlsx"),
                     asTable = TRUE,
                     overwrite = TRUE) 

openxlsx::write.xlsx(x = signifLog2Promoters_UP_goEnrichment_df, 
                     file = paste0(patient_vs_NDs_results_dir, "/de_results_patient_vs_NDs_signifLog2Promoters_UP_GOenrich.xlsx"),
                     asTable = TRUE,
                     overwrite = TRUE) 

openxlsx::write.xlsx(x = signifLog2Promoters_DOWN_goEnrichment_df, 
                     file = paste0(patient_vs_NDs_results_dir, "/de_results_patient_vs_NDs_signifLog2Promoters_DOWN_GOenrich.xlsx"),
                     asTable = TRUE,
                     overwrite = TRUE) 

# also add filtering criteria!
message("Saving GOBP enrichment results")
save(signifPadj_goEnrichment, signifLog2Promoters_goEnrichment,
     file = file.path(patient_vs_NDs_results_dir, "de_results_goEnrich.RData"))

# accessibility heatmap ----
# - [ ] add results from enricheR - they differ a bit; z-scores?

# plotting GO term enrichment
# top 25 and top50
signifLog2Promoters_DOWN_goEnrichment_df <- purrr::map(.x = signifLog2Promoters_goEnrichment$down, .f = as.data.frame) %>% setNames(names(signifLog2Promoters_goEnrichment$down))

signifLog2Promoters_DOWN_goEnrichment_GOBP <- signifLog2Promoters_DOWN_goEnrichment_df$GOBP

# collapse go terms?

ntop_GOTERMS=50
signifLog2Promoters_DOWN_goEnrichment_GOBP_toPlot <- signifLog2Promoters_DOWN_goEnrichment_GOBP %>%
  dplyr::filter(p.adjust < 0.05) %>%
  dplyr::mutate(log10padj = -log(p.adjust, base = 10)) %>%
  dplyr::arrange(desc(log10padj)) #%>%
  #dplyr::mutate(Description = stringr::str_wrap(Description, width = 30)) %>% # wrapping really long names; in ggplot below
  #dplyr::mutate(Description = factor(Description, levels = Description)) #%>% dplyr::slice_head(n = ntop_GOTERMS)

signifLog2Promoters_DOWN_goEnrichment_GOBP_toPlot$Description <- factor(signifLog2Promoters_DOWN_goEnrichment_GOBP_toPlot$Description, levels = signifLog2Promoters_DOWN_goEnrichment_GOBP_toPlot$Description)

# https://ggplot2.tidyverse.org/reference/geom_bar.html
signifLog2Promoters_DOWN_GOBP_barplot <- ggplot(signifLog2Promoters_DOWN_goEnrichment_GOBP_toPlot[1:ntop_GOTERMS,], aes(x=log10padj, y=fct_rev(Description), fill = log10padj)) + 
  scale_y_discrete(labels = scales::wrap_format(60)) +
  geom_col() +
  theme_bw() +
  xlab("-log10(padj)") + ylab("") +
  labs(fill = "-log10(padj)") + 
  scale_fill_gradient2(low="navy", mid="white", high="red", 
                       midpoint=0)
  # scale_fill_gradientn(colours = colorspace::heat_hcl(7))
  # scale_fill_gradientn(colours = terrain.colors(7))
  # paletteer::scale_fill_paletteer_c("gameofthrones::targaryen")
  # scale_fill_distiller(palette = "RdPu")
  # scale_fill_gradient2(low = "yellow", high = "red", na.value = NA, midpoint = 1.3)

ggsave(signifLog2Promoters_DOWN_GOBP_barplot, filename = paste0(patient_vs_NDs_results_dir, "/signifLog2Promoters_DOWN_GOBP_barplot_ntop",ntop_GOTERMS,".pdf"))
ggsave(signifLog2Promoters_DOWN_GOBP_barplot, filename = paste0(patient_vs_NDs_results_dir, "/signifLog2Promoters_DOWN_GOBP_barplot_ntop",ntop_GOTERMS,".png"))

# only top25
ntop_GOTERMS=25

# https://ggplot2.tidyverse.org/reference/geom_bar.html
signifLog2Promoters_DOWN_GOBP_barplot <- ggplot(signifLog2Promoters_DOWN_goEnrichment_GOBP_toPlot[1:ntop_GOTERMS,], aes(x=log10padj, y=fct_rev(Description), fill = log10padj)) + 
  scale_y_discrete(labels = scales::wrap_format(60)) +
  geom_col() +
  theme_bw() +
  xlab("-log10(padj)") + ylab("") +
  labs(fill = "-log10(padj)") + 
  scale_fill_gradient2(low="navy", mid="white", high="red", 
                       midpoint=0)
  # scale_fill_gradientn(colours = colorspace::heat_hcl(7))
  # scale_fill_gradientn(colours = terrain.colors(7))
  # paletteer::scale_fill_paletteer_c("gameofthrones::targaryen")
  # scale_fill_distiller(palette = "RdPu")

# width = 10, height = 20, units = "cm"
ggsave(signifLog2Promoters_DOWN_GOBP_barplot, filename = paste0(patient_vs_NDs_results_dir, "/signifLog2Promoters_DOWN_GOBP_barplot_ntop",ntop_GOTERMS,".pdf"))
ggsave(signifLog2Promoters_DOWN_GOBP_barplot, filename = paste0(patient_vs_NDs_results_dir, "/signifLog2Promoters_DOWN_GOBP_barplot_ntop",ntop_GOTERMS,".png"))

```

```{r plotting IL2, include=TRUE, eval=TRUE, message=FALSE}
# IL2, STAT1
# IL2 - entrez_id: 3558
# - [ ] add peak info - where is the peak!!!
gene_cols <- c("gene_id", "tx_id", "tx_name", "tx_chrom", "tx_strand")
txdb_genes <- GenomicFeatures::genes(txdb, columns=gene_cols, single.strand.genes.only=TRUE)
IL2_region <- txdb_genes[txdb_genes$gene_id == "3558"]
extend_region <- 2000
start(IL2_region) <- start(IL2_region)  - extend_region  # extending region aroung IL2
end(IL2_region) <- end(IL2_region)  + extend_region
start(IL2_region)
end(IL2_region)

#IL2_region <- regioneR::toGRanges("chr4:122448970-122459225") + 2kb around
# start(IL2_region) <- start(IL2_region) - 500
# end(IL2_region) <- start(IL2_region)  500

#kp <- karyoploteR::plotKaryotype(genome = "hg38", zoom = IL2_region)

genes.data <- karyoploteR::makeGenesDataFromTxDb(txdb = txdb,
                                    karyoplot=kp,
                                    plot.transcripts = TRUE, 
                                    plot.transcripts.structure = TRUE)

kp <- plotKaryotype(genome = "hg38", zoom = IL2_region, cex=2)
karyoploteR::kpPlotGenes(kp, data=genes.data)

genes.data <- karyoploteR::addGeneNames(genes.data, orgDb="auto")
genes.data <- karyoploteR::mergeTranscripts(genes.data)

pp <- getDefaultPlotParams(plot.type=1)
pp$leftmargin <- 0.15
pp$topmargin <- 15
pp$bottommargin <- 15
pp$ideogramheight <- 5
pp$data1inmargin <- 10
pp$data1outmargin <- 0

gene_toPlot="IL2"
# samples_bw <- c(patient="/home/peter_r/datasets/Patient/aligned_hg38/Patient_smooth.bw",
#                 nd01="/home/peter_r/datasets/ND_01/aligned_hg38/ND_01_smooth.bw",
#                 nd02="/home/peter_r/datasets/ND_02/aligned_hg38/ND_02_smooth.bw")
samples_bw <- c(patient="/home/peter_r/datasets/Patient/aligned_hg38/Patient_SeqDepthNorm_smooth.bw",
                nd01="/home/peter_r/datasets/ND_01/aligned_hg38/ND_01_SeqDepthNorm_smooth.bw",
                nd02="/home/peter_r/datasets/ND_02/aligned_hg38/ND_02_SeqDepthNorm_smooth.bw")

kp <- plotKaryotype(zoom = IL2_region, cex=2, genome = "hg38", plot.params = pp)
kpAddBaseNumbers(kp, tick.dist = 10000, minor.tick.dist = 2000,
                add.units = TRUE, cex=2, tick.len = 3)
kpAddMainTitle(kp, paste0("ATAC-seq signal in ", gene_toPlot), cex=2)
kpPlotGenes(kp, data=genes.data, r0=0, r1=0.1, gene.name.cex = 2.5)

#atac-seq signal
total.tracks <- length(samples_bw) #+length(DNA.binding)
out.at <- autotrack(1:length(samples_bw), total.tracks, margin = 0.3, r0=0.23)
# kpAddLabels(kp, labels = "Sample name", r0 = out.at$r0, r1=out.at$r1, cex=3.5,
#             srt=90, pos=1, label.margin = 0.14)

# normalized?
# https://rdrr.io/bioc/karyoploteR/man/kpPlotBAMDensity.html

# kpAddLabels(kp, labels = "RPKM", r0 = out.at$r0, r1=out.at$r1,
#              cex=1.0, srt=90, pos=1, label.margin = 0.035)  # 0.14
# kpAddLabels(kp, labels = "log2 FC", srt=90, pos=1, label.margin = 0.04, ymax=fc.ymax, ymin=fc.ymin, r1=points.top)
for(i in seq_len(length(samples_bw))) {
  bigwig.file <- samples_bw[i]
  at <- autotrack(i, length(samples_bw), r0=out.at$r0, r1=out.at$r1, margin = 0.1)
  if (names(bigwig.file) == "patient") {
      kp <- kpPlotBigWig(kp, data=bigwig.file, 
                         ymax=130,
                         #ymax="visible.region",
                     r0=at$r0, r1=at$r1, col = "red")
  } else {
    kp <- kpPlotBigWig(kp, data=bigwig.file, 
                       ymax=130,
                       #ymax="visible.region",
                     r0=at$r0, r1=at$r1, col = "cadetblue2")
  }
    
  computed.ymax <- ceiling(kp$latest.plot$computed.values$ymax)  # 26 - max from nd02; fix the scale?!
  kpAxis(kp, ymin=0, 
         ymax=computed.ymax, 
         #tick.pos = c(130),
         tick.pos = computed.ymax, 
         r0=at$r0, r1=at$r1, cex=1.6)
  kpAddLabels(kp, labels = "RPKM", r0=at$r0, r1=at$r1,
              cex=1.0, srt=90, pos=1, label.margin = 0.02)  # 0.14
  kpAddLabels(kp, labels = names(samples_bw)[i], r0=at$r0, r1=at$r1, 
              cex=1.6, label.margin = 0.05)  # 0.035
}


# saving as pdf
# - [ ] redo above so it is stored as function!

pdf(file = file.path(out_dir, paste0("gene_tracks_",gene_toPlot, ".pdf")), width=18, height=10)
kp <- plotKaryotype(zoom = IL2_region, cex=2, genome = "hg38", plot.params = pp)
kpAddBaseNumbers(kp, tick.dist = 10000, minor.tick.dist = 2000,
                add.units = TRUE, cex=2, tick.len = 3)
kpAddMainTitle(kp, paste0("ATAC-seq signal in ", gene_toPlot), cex=2)
kpPlotGenes(kp, data=genes.data, r0=0, r1=0.1, gene.name.cex = 2.5)

#atac-seq signal
total.tracks <- length(samples_bw) #+length(DNA.binding)
out.at <- autotrack(1:length(samples_bw), total.tracks, margin = 0.3, r0=0.23)
# kpAddLabels(kp, labels = "Sample name", r0 = out.at$r0, r1=out.at$r1, cex=3.5,
#             srt=90, pos=1, label.margin = 0.14)

# normalized?
# https://rdrr.io/bioc/karyoploteR/man/kpPlotBAMDensity.html

# kpAddLabels(kp, labels = "RPKM", r0 = out.at$r0, r1=out.at$r1,
#              cex=1.0, srt=90, pos=1, label.margin = 0.035)  # 0.14
# kpAddLabels(kp, labels = "log2 FC", srt=90, pos=1, label.margin = 0.04, ymax=fc.ymax, ymin=fc.ymin, r1=points.top)
for(i in seq_len(length(samples_bw))) {
  bigwig.file <- samples_bw[i]
  at <- autotrack(i, length(samples_bw), r0=out.at$r0, r1=out.at$r1, margin = 0.1)
  if (names(bigwig.file) == "patient") {
      kp <- kpPlotBigWig(kp, data=bigwig.file, 
                         ymax=130,
                         #ymax="visible.region",
                     r0=at$r0, r1=at$r1, col = "red")
  } else {
    kp <- kpPlotBigWig(kp, data=bigwig.file, 
                       ymax=130,
                       #ymax="visible.region",
                     r0=at$r0, r1=at$r1, col = "cadetblue2")
  }
    
  computed.ymax <- ceiling(kp$latest.plot$computed.values$ymax)  # 26 - max from nd02; fix the scale?!
  kpAxis(kp, ymin=0, 
         ymax=computed.ymax, 
         #tick.pos = c(130),
         tick.pos = computed.ymax, 
         r0=at$r0, r1=at$r1, cex=1.6)
  kpAddLabels(kp, labels = "RPKM", r0=at$r0, r1=at$r1,
              cex=1.0, srt=90, pos=1, label.margin = 0.02)  # 0.14
  kpAddLabels(kp, labels = names(samples_bw)[i], r0=at$r0, r1=at$r1, 
              cex=1.6, label.margin = 0.05)  # 0.035
}

dev.off()

png(filename = file.path(out_dir, paste0("gene_tracks_",gene_toPlot, ".png")))
kp <- plotKaryotype(zoom = IL2_region, cex=2, genome = "hg38", plot.params = pp)
kpAddBaseNumbers(kp, tick.dist = 10000, minor.tick.dist = 2000,
                add.units = TRUE, cex=2, tick.len = 3)
kpAddMainTitle(kp, paste0("ATAC-seq signal in ", gene_toPlot), cex=2)
kpPlotGenes(kp, data=genes.data, r0=0, r1=0.1, gene.name.cex = 2.5)

#atac-seq signal
total.tracks <- length(samples_bw) #+length(DNA.binding)
out.at <- autotrack(1:length(samples_bw), total.tracks, margin = 0.3, r0=0.23)
# kpAddLabels(kp, labels = "Sample name", r0 = out.at$r0, r1=out.at$r1, cex=3.5,
#             srt=90, pos=1, label.margin = 0.14)

# normalized?
# https://rdrr.io/bioc/karyoploteR/man/kpPlotBAMDensity.html

# kpAddLabels(kp, labels = "RPKM", r0 = out.at$r0, r1=out.at$r1,
#              cex=1.0, srt=90, pos=1, label.margin = 0.035)  # 0.14
# kpAddLabels(kp, labels = "log2 FC", srt=90, pos=1, label.margin = 0.04, ymax=fc.ymax, ymin=fc.ymin, r1=points.top)
for(i in seq_len(length(samples_bw))) {
  bigwig.file <- samples_bw[i]
  at <- autotrack(i, length(samples_bw), r0=out.at$r0, r1=out.at$r1, margin = 0.1)
  if (names(bigwig.file) == "patient") {
      kp <- kpPlotBigWig(kp, data=bigwig.file, 
                         ymax=130,
                         #ymax="visible.region",
                     r0=at$r0, r1=at$r1, col = "red")
  } else {
    kp <- kpPlotBigWig(kp, data=bigwig.file, 
                       ymax=130,
                       #ymax="visible.region",
                     r0=at$r0, r1=at$r1, col = "cadetblue2")
  }
    
  computed.ymax <- ceiling(kp$latest.plot$computed.values$ymax)  # 26 - max from nd02; fix the scale?!
  kpAxis(kp, ymin=0, 
         ymax=computed.ymax, 
         #tick.pos = c(130),
         tick.pos = computed.ymax, 
         r0=at$r0, r1=at$r1, cex=1.6)
  kpAddLabels(kp, labels = "RPKM", r0=at$r0, r1=at$r1,
              cex=1.0, srt=90, pos=1, label.margin = 0.02)  # 0.14
  kpAddLabels(kp, labels = names(samples_bw)[i], r0=at$r0, r1=at$r1, 
              cex=1.6, label.margin = 0.05)  # 0.035
}

dev.off()


# pdf(file = file.path(out_dir, paste0("gene_tracks_",gene_toPlot, ".pdf")), width=18, height=10)
# kp <- plotKaryotype(zoom = IL2_region, cex=2, genome = "hg38", plot.params = pp) %>%
#   kpAddBaseNumbers(., tick.dist = 10000, minor.tick.dist = 2000,
#                  add.units = TRUE, cex=2, tick.len = 3) %>%
#   kpAddMainTitle(., paste0("ATAC-seq signal in ", gene_toPlot), cex=2) %>%
#   kpPlotGenes(., data=genes.data, r0=0, r1=0.1, gene.name.cex = 2.5)
# 
# #atac-seq signal
# total.tracks <- length(samples_bw) #+length(DNA.binding)
# out.at <- autotrack(1:length(samples_bw), total.tracks, margin = 0.3, r0=0.23)
# # kpAddLabels(kp, labels = "Sample name", r0 = out.at$r0, r1=out.at$r1, cex=3.5,
# #             srt=90, pos=1, label.margin = 0.14)
# 
# for(i in seq_len(length(samples_bw))) {
#   bigwig.file <- samples_bw[i]
#   at <- autotrack(i, length(samples_bw), r0=out.at$r0, r1=out.at$r1, margin = 0.1)
#   if (names(bigwig.file) == "patient") {
#       kp <- kp %>% 
#         kpPlotBigWig(., data=bigwig.file, 
#                          ymax=26,
#                          #ymax="visible.region",
#                      r0=at$r0, r1=at$r1, col = "red")
#   } else {
#     kp <- kp %>% 
#       kpPlotBigWig(., data=bigwig.file, 
#                        ymax=26,
#                        #ymax="visible.region",
#                      r0=at$r0, r1=at$r1, col = "cadetblue2")
#   }
#     
#   computed.ymax <- ceiling(kp$latest.plot$computed.values$ymax)  # 26 - max from nd02; fix the scale?!
#   kp <- kp %>% 
#     kpAxis(., ymin=0, 
#          ymax=computed.ymax, 
#          tick.pos = c(26),
#          #tick.pos = computed.ymax, 
#          r0=at$r0, r1=at$r1, cex=1.6)
#   kp <- kp %>% 
#     kpAddLabels(., labels = names(samples_bw)[i], r0=at$r0, r1=at$r1, 
#               cex=1.6, label.margin = 0.035)
# }
# 
# dev.off()




# plotting density - normalizing
# 
# kp <- karyoploteR::plotKaryotype(genome = "hg38", zoom = IL2_region)
# 
# genes.data <- karyoploteR::makeGenesDataFromTxDb(txdb = txdb,
#                                     karyoplot=kp,
#                                     plot.transcripts = TRUE, 
#                                     plot.transcripts.structure = TRUE)
# 
# kp <- plotKaryotype(genome = "hg38", zoom = IL2_region, cex=2)
# karyoploteR::kpPlotGenes(kp, data=genes.data)
# 
# genes.data <- karyoploteR::addGeneNames(genes.data, orgDb="auto")
# genes.data <- karyoploteR::mergeTranscripts(genes.data)
# 
# pp <- getDefaultPlotParams(plot.type=1)
# pp$leftmargin <- 0.15
# pp$topmargin <- 15
# pp$bottommargin <- 15
# pp$ideogramheight <- 5
# pp$data1inmargin <- 10
# pp$data1outmargin <- 0
# 
# gene_toPlot="IL2"
# samples_bam <- c(patient="/home/peter_r/datasets/Patient/aligned_hg38/Patient_sort_dedup.bam",
#                 nd01="/home/peter_r/datasets/ND_01/aligned_hg38/ND_01_sort_dedup.bam",
#                 nd02="/home/peter_r/datasets/ND_02/aligned_hg38/ND_02_sort_dedup.bam")
# 
# use above and replace with kpPlotBAMDensity + normalized

```

```{r finding Motifs, include=FALSE, eval=FALSE, cache=TRUE}
#genes_interest <- c("IKZF1", "IKZF2", "NFAT5", "NFATC1", "NFATC2", "NFATC3", "NFATC4", "NFKB")

# IKZF1 and IKZF2
# IKZF1 <- query(MotifDb, c("IKZF1")) 
# IKZF1_IKAROS <- query(MotifDb, c("IKAROS")) # ?? one match points to one of the above resource: Hsapiens-HOCOMOCOv11-core-C-IKZF1_HUMAN.H11MO.0.C
# IKZF2 <- query(MotifDb, c("IKZF2")) 
# # IKZF2_HELIOS <- query(MotifDb, c("HELIOS")) # NULL
# JUN <- query(MotifDb, c("JUN"))  #  there are multiple JUN entries
# 
# names(IKZF2)
# 
# ikzf1_jaspar_Motif <- IKZF1[["Hsapiens-HOCOMOCOv10-IKZF1_HUMAN.H10MO.C"]]
# ikzf1_Motif <- IKZF1[["Hsapiens-SwissRegulon-IKZF1.SwissRegulon"]]
# ikzf2_Motif <- IKZF2[["Hsapiens-SwissRegulon-IKZF2.SwissRegulon"]]
# 
# ikzf1_Motif[, 1:4]
# ikzf2_Motif[, 1:4]
# 
# seqLogo(ikzf1_jaspar_Motif)
# seqLogo(ikzf1_Motif)
# seqLogo(ikzf2_Motif)

# TFBSTools for motif sets

# Identifying Motifs in ATACs-seq ---
#First we can retrieve a sensible set of motifs to scan for within our mouse tissue ATACseq data.
#Here we retrieve the vertebrate, JASPAR CORE motifs. We additional specify all_versions is FALSE to only include the latest version of a motif.

if (!file.exists(paste0(out_dir, "/motif_enrichment.RData"))) {
  #?getMatrixSet
  opts <- list()
  opts[["tax_group"]] <- "vertebrates"
  opts[["species"]] <- "9606"
  opts[["collection"]] <- "CORE"
  opts[["all_versions"]] <- FALSE
  motifsToScan <- TFBSTools::getMatrixSet(JASPAR2020, opts)
  
  # summarizing ATAC signal to Motifs ----
  # The chromVar package allows for the summarization of ATACseq signal changes to the motifs within peaks.
  # With this summarization we can potentially identify which motifs may have an important role in a set of ATAC samples compared to other samples.
  # The chromVar package comes from the same lab and author as the motifmatchr package and so will work well together.
  
  # Setting up for chromVar ----
  #To identify motifs for chomVar we will use motifMatchr with a different set of inputs.
  #Here we will provide our RangedSummarizedExperiment object contaitng our counts over peaks directly to the matchMotifs function.
  
  #First we will remove any peaks with less than 5 reads across all samples.
  colData(counts_consensus) <- colData(atacDDS)
  
  # using normalized counts from DESeq2
  #counts(counts_consensus) <- atacDDS_normCounts
  
  dim(counts_consensus)
  counts_consensus_filt <- counts_consensus[rowSums(assay(counts_consensus)) > 5, ]
  dim(counts_consensus)
  
  #Correct GC bias ---
  
  #Next we can correct for any potential GC bias which may have arisen in sequencing. 
  # - there seems to be no GC bias so probably not needed. But check initial QC using also ChIPQC packageS?
  
  #For comparing across differing sets of peaks with differing sequences compositions we will need to correct for this bias. We can use the addGCBias and specify our genome as a BSgenome object to correct in chromVar.
  # Computes GC content for peaks
  # rather use fasta file - https://greenleaflab.github.io/chromVAR/articles/Introduction.html#visualizing-deviations
  # or DNAStringSet 

  # added extra
  # counts_consensus_filt <- chromVAR::filterPeaks(counts_consensus_filt, non_overlapping = TRUE)
  # dim(counts_consensus_filt)  # makes no difference
  
  # added extra
  #fastq_file <- "/home/peter_r/resources/hg38.fa"
  #fasta_ref <- Rsamtools::FaFile(fastq_file, index=sprintf("%s.fai", fastq_file))
  #counts_consensus_filt <- chromVAR::addGCBias(counts_consensus_filt, genome = fasta_ref)  # or rather use FaFile!
  #B <- chromVAR::addGCBias(counts_consensus_filt, genome = fasta_ref)
  
  counts_consensus_filt <- chromVAR::addGCBias(counts_consensus_filt, genome = BSgenome.Hsapiens.UCSC.hg38)  # or rather use FaFile!
  #A <- chromVAR::addGCBias(counts_consensus_filt, genome = BSgenome.Hsapiens.UCSC.hg38)
  #A_bias <- rowData(A)$bias #head(rowData(A))
  #B_bias <- rowData(B)$bias #head(rowData(A))
  #identical(A_bias, B_bias) TRUE
  # ID motifs in peaks ----
  
  # Having corrected for bias, we can use the matchMotifs function again to identify motifs under our ATACseq peaks.
  # Here we supply our RangedSummarizedExperiment of counts in peaks and the genome of interest to the matchMotifs function and use the default out of matches.
  
  # added extra - not used!
  # but this fetches JASPAR2016!?
  #motifsToScan <- chromVAR::getJasparMotifs(species = "Homo sapiens", collection = "CORE") # instead of using the above function; compare!
  
  # BSgenome.Hsapiens.UCSC.hg38 compare to NCBI sequence used in the PEPATAC
  # identical with NCBI fasta used in PEPATAC when genome = fasta_ref
  motif_matches <- motifmatchr::matchMotifs(pwms = motifsToScan, 
                                            subject = counts_consensus_filt, 
                                            genome = BSgenome.Hsapiens.UCSC.hg38, 
                                            out = "matches")
  motif_matches
  
  # Run chromVar ----
  
  #Following the identification of motifs in our peaks, we can perform the summarization of ATACseq signal to motifs using the computeDeviations and the computeVariability functions.
  
  # Computes deviations in chromatin accessibility across sets of annotations
  # https://bioconductor.org/packages/release/bioc/vignettes/chromVAR/inst/doc/Introduction.html
  # library(BiocParallel)
  BiocParallel::register(BiocParallel::MulticoreParam(8, progressbar = FALSE))
  set.seed(2021) # !!! seed needs to be set otherwise results differ !!! 
  #register(SerialParam())
  
  # deviations
  # The function computeDeviations returns a SummarizedExperiment with two “assays”. The first matrix (accessible via deviations(dev) or assays(dev)$deviations) will give the bias corrected “deviation” in accessibility for each set of peaks (rows) for each cell or sample (columns). This metric represent how accessible the set of peaks is relative to the expectation based on equal chromatin accessibility profiles across cells/samples, normalized by a set of background peak sets matched for GC and average accessability. The second matrix (deviationScores(dev) or assays(deviations)$z) gives the deviation Z-score, which takes into account how likely such a score would occur if randomly sampling sets of beaks with similar GC content and average accessibility.
  
  # The deviations result contains a SummarizedExperiment object with the Z-scores showing the enrichment for ATACseq signal in each sample for every motif.
  
  # Computes deviations in chromatin accessibility across sets of annotations
  # - [ ] what it actually calculates??? see details!
  
  # added extra
  # per-compute background peaks only on middle bit of overlapping peaks
  # or potentially use normalized counts from DESeq?! - why are normalized counts not used by default???!
  # adde extra 
  #  https://greenleaflab.github.io/chromVAR/articles/Articles/Deviations.html
  # use group info to calculate expectations!
  background_peaks <- chromVAR::getBackgroundPeaks(object = counts_consensus_filt) 
  # expectation below seems to produce same results? all.equal() TRUE
  access_expectation <- chromVAR::computeExpectations(object = counts_consensus_filt)  # default
  #access_expectation <- chromVAR::computeExpectations(object = counts_consensus_filt, norm = TRUE) 
  # Warning message:
  # In if (norm) { :
  #  the condition has length > 1 and only the first element will be used
   # access_expectation <- chromVAR::computeExpectations(object = counts_consensus_filt, group = colData(counts_consensus_filt)$sample_group) # at least two samples for normalization!
  #access_expectation <- chromVAR::computeExpectations(object = counts_consensus_filt, colData(counts_consensus_filt)$sample_group) 
  #access_expectation <- chromVAR::computeExpectations(object = counts_consensus_filt, colData(counts_consensus_filt)$sample_group, norm = TRUE) # this or group = "sample_group" are identical!

  chrom_access_deviations <- chromVAR::computeDeviations(object = counts_consensus_filt, 
                                                         annotations = motif_matches,
                                                         background_peaks = background_peaks,
                                                         expectation = access_expectation)
  # adding samples names
  #colData(chrom_access_deviations)
  #colData(counts_consensus_filt)
  
  #colData(chrom_access_deviations) <- colData(atacDDS)  # check if order of samples is the same between chrom_access_deviations and atacDDS
  
  # 
  sample_cor <- chromVAR::getSampleCorrelation(chrom_access_deviations)
  
  #library(pheatmap)
  annotation_row_sampleCor <- as.data.frame(colData(chrom_access_deviations)) %>%
    dplyr::select(sample_group)
  pheatmap::pheatmap(as.dist(sample_cor), 
                     annotation_row = annotation_row_sampleCor, 
                     clustering_distance_rows = as.dist(1-sample_cor), 
                     clustering_distance_cols = as.dist(1-sample_cor))
  
  # assessing similarity
  # tsne_results <- chromVAR::deviationsTsne(chrom_access_deviations, threshold = 1.5, perplexity = 20, 
  #                              shiny = FALSE)
  # tsne_plots <- chromVAR::plotDeviationsTsne(dev, tsne_results, annotation = "IKZF1", 
  #                                  sample_column = "sample_group", shiny = FALSE)
  # tsne_plots[[1]]
  # tsne_plots[[2]]
  
  # Motif / kmer similarity
  inv_tsne_results <- deviationsTsne(chrom_access_deviations, threshold = 1.5, perplexity = 8, 
                                    what = "annotations", shiny = FALSE)

ggplot(inv_tsne_results, aes(x = Dim1, y = Dim2)) + geom_point() + 
  chromVAR_theme()
    
  # Differential accessibility and variability of motifs!
  # https://greenleaflab.github.io/chromVAR/articles/Articles/Applications.html
  diff_acc <- chromVAR::differentialDeviations(chrom_access_deviations, groups="sample_group", parametric = FALSE)
  head(diff_acc)  ## parametric = TRUE not enough 'y' observations
  
  devZscores <- chromVAR::deviationScores(chrom_access_deviations)
  devZscores_df <- tibble::rownames_to_column(as.data.frame(devZscores), var="jaspar_id")
  
  # function to compute overall variability of motif sets across samples ----
  chrom_access_variability <- chromVAR::computeVariability(chrom_access_deviations)
  #plotVariability(chrom_access_variability, use_plotly = FALSE)
  
  BiocParallel::register(BiocParallel::SerialParam())

  chrom_access_variability_ord <- chrom_access_variability[order(chrom_access_variability$p_value), ]  # ordering based on p-value
  #chrom_access_variability_ord[1:10, ]

  #! to store
  chrom_access_variability_ord_results <- chrom_access_variability_ord %>%
    tibble::rownames_to_column(var="jaspar_id") %>%
    dplyr::left_join(., devZscores_df, by = "jaspar_id")
  
  chrom_access_variability_ord_results_signifConsistPatients <- chrom_access_variability_ord_results %>%
    dplyr::filter(p_value_adj < 0.05) %>%
    dplyr::mutate(nd_same_direction = if_else(sign(ND_01) == sign(ND_02), TRUE, FALSE)) %>%
    dplyr::filter(nd_same_direction == TRUE)
  
  #sum(chrom_access_variability_ord_results$p_value_adj < 0.05)
  
  #plotVariability(chrom_access_variability, use_plotly = FALSE) 
  
  message("Saving motif enrichment results")
  save(chrom_access_deviations, chrom_access_variability, chrom_access_variability_ord, chrom_access_variability_ord_results, file = paste0(out_dir, "/motif_enrichment.RData"))
} else {
  
  message("Loading motif enrichment results")
  load(file = paste0(out_dir, "/motif_enrichment.RData"))
  
  devZscores <- chromVAR::deviationScores(chrom_access_deviations)
  devZscores_df <- tibble::rownames_to_column(as.data.frame(devZscores), var="jaspar_id")
  
}

# chromVar results ----

# We can use the results from the variability with our Z-score deviations to identify in which sample our motifs are enriched.
ntop <- 50
topVariable <- chrom_access_variability_ord[1:ntop, ]
topVariable <- tibble::rownames_to_column(topVariable, var="jaspar_id")

#devTop <- merge(topVariable[, 1, drop = FALSE], devZscores, by = 0)  # by = 0 - rownames; but gives random order?!
devTop <- topVariable %>%
  dplyr::left_join(., devZscores_df, by = "jaspar_id")
#devTop[1:2, ]

# A useful way to visualize these results is using a heatmap. Although we cover this in a later session, here we can use the pheatmap library with default settings to illustrate where our most variable motifs are active.
#devToPlot <- as.matrix(devTop[, -c(1:2)])
devToPlot <- devTop %>%
  dplyr::select(name, ND_01, ND_02, Patient) %>%
  tibble::column_to_rownames(var = "name")
#rownames(devToPlot) <- devTop[, 2]
#library(pheatmap)
# annotCol_forHeatmap <- project_metadata %>%
#   dplyr::select(sample_name, condition) %>%
#   tibble::column_to_rownames(var="sample_name")

pheatmap::pheatmap(devToPlot, 
                   scale="none", 
                   cluster_cols = FALSE, 
                   annotation_col = annotCol_forHeatmap, 
                   main = paste0("Heatmap of motif enrichment - top ", ntop))
# pheatmap::pheatmap(devToPlot, 
#                    scale = "none", 
#                    cluster_cols = FALSE,
#                    annotation_col = annotCol_forHeatmap,
#                    main = paste0("Heatmap of motif enrichment - top ", ntop),
#                    filename = file.path(out_dir, paste0("motif_enrichment_signifTop", ntop,".pdf")))
# 
# pheatmap::pheatmap(devToPlot, 
#                    scale = "none", 
#                    cluster_cols = FALSE,
#                    annotation_col = annotCol_forHeatmap,
#                    main = paste0("Heatmap of motif enrichment - top ", ntop),
#                    filename = file.path(out_dir, paste0("motif_enrichment_signifTop", ntop,".png")))
#motif_dev_heatmap <- ComplexHeatmap::pheatmap(as.matrix(devToPlot), scale="none", cluster_cols = FALSE)

# replacing heatmap with publication heatmap ----
library("RColorBrewer")
annotCol_forHeatmap_colors <- list(genotype = c(  WT="#525252", `I325V-Hom` = "#fc4e2a"),
                                   bio_rep = c(ND_01 = "#d9d9d9", ND_02= "#969696", Patient = "#fd8d3c"))
#motifs_heatmap <-  
pheatmap::pheatmap(as.matrix(devToPlot),
                   color = colorRampPalette(rev(brewer.pal(7, "PiYG")))(100),
                   scale = "row",
                   #gaps_col = ph_col_annot%>% arrange(state)%$% table(state) %>% cumsum,
                   #gaps_row = ph_genes$clust %>% table() %>% cumsum,
                   cluster_cols = FALSE,
                   cluster_rows = TRUE,
                   show_colnames = FALSE,
                   show_rownames = TRUE,
                   annotation_col = annotCol_forHeatmap,
                   #annotation_row = ph_row_annot,
                   #annotation_legend = FALSE,
                   annotation_colors = annotCol_forHeatmap_colors,  
                   #labels_row = row_labels,
                   fontsize_row = 9,
                   fontsize = 9)

pheatmap::pheatmap(as.matrix(devToPlot),
                   color = colorRampPalette(rev(brewer.pal(7, "PiYG")))(100),
                   scale = "row",
                   #gaps_col = ph_col_annot%>% arrange(state)%$% table(state) %>% cumsum,
                   #gaps_row = ph_genes$clust %>% table() %>% cumsum,
                   cluster_cols = FALSE,
                   cluster_rows = TRUE,
                   show_colnames = FALSE,
                   show_rownames = TRUE,
                   annotation_col = annotCol_forHeatmap,
                   #annotation_row = ph_row_annot,
                   #annotation_legend = FALSE,
                   annotation_colors = annotCol_forHeatmap_colors,  
                   #labels_row = row_labels,
                   fontsize_row = 9,
                   fontsize = 9,
                   #cellheight = 9,
                   main = paste0("Heatmap of motif enrichment - top ", ntop),
                   filename = file.path(out_dir, paste0("motif_enrichment_signifTop", ntop,".pdf")))

pheatmap::pheatmap(as.matrix(devToPlot),
                   color = colorRampPalette(rev(brewer.pal(7, "PiYG")))(100),
                   scale = "row",
                   #gaps_col = ph_col_annot%>% arrange(state)%$% table(state) %>% cumsum,
                   #gaps_row = ph_genes$clust %>% table() %>% cumsum,
                   cluster_cols = FALSE,
                   cluster_rows = TRUE,
                   show_colnames = FALSE,
                   show_rownames = TRUE,
                   annotation_col = annotCol_forHeatmap,
                   #annotation_row = ph_row_annot,
                   #annotation_legend = FALSE,
                   annotation_colors = annotCol_forHeatmap_colors,  
                   #labels_row = row_labels,
                   fontsize_row = 9,
                   fontsize = 9,
                   #cellheight = 9,
                   main = paste0("Heatmap of motif enrichment - top ", ntop),
                   filename = file.path(out_dir, paste0("motif_enrichment_signifTop", ntop,".png")))

# pdf(file.path(out_dir, paste0("motif_enrichment_signifTop", ntop,".pdf")))
# grid.draw(motifs_heatmap)
# dev.off()

openxlsx::write.xlsx(x = chrom_access_variability_ord_results, 
                     file = paste0(out_dir, "/motif_enrichment.xlsx"),
                     asTable = TRUE,
                     overwrite = TRUE) 


```

```{r cutnrun}
library("GenomicAlignments")
flags = scanBamFlag(isProperPair = TRUE)
bam_params <- ScanBamParam(flag = flags, what = c("qname", "mapq", "isize"))
Patient_H3K27Ac_R1_sortedBAM <- file.path("/home/peter_r/cutnrun_data/quick_check/bam_files/Patient_H3K27Ac_R1.markdup.bam")

cutnrun_reads <- readGAlignmentPairs(Patient_H3K27Ac_R1_sortedBAM, param = bam_params)
class(cutnrun_reads)

cutnrun_reads[1:2, ]
read1 <- first(cutnrun_reads)
read2 <- second(cutnrun_reads)
read2[1, ]

read1MapQ <- mcols(read1)$mapq
read2MapQ <- mcols(read2)$mapq
read1MapQ[1:2]

read1MapQFreqs <- table(read1MapQ)
read2MapQFreqs <- table(read2MapQ)
read1MapQFreqs
read2MapQFreqs

toPlot <- data.frame(MapQ = c(names(read1MapQFreqs), names(read2MapQFreqs)), Frequency = c(read1MapQFreqs, 
    read2MapQFreqs), Read = c(rep("Read1", length(read1MapQFreqs)), rep("Read2", 
    length(read2MapQFreqs))))
toPlot$MapQ <- factor(toPlot$MapQ, levels = unique(sort(as.numeric(toPlot$MapQ))))
ggplot(toPlot, aes(x = MapQ, y = Frequency, fill = MapQ)) + geom_bar(stat = "identity") + 
    facet_grid(~Read)

cutnrun_reads_read1 <- first(cutnrun_reads)
insertSizes <- abs(elementMetadata(cutnrun_reads_read1)$isize)
head(insertSizes)

fragLenSizes <- table(insertSizes)
fragLenSizes[1:5]

toPlot <- data.frame(InsertSize = as.numeric(names(fragLenSizes)), Count = as.numeric(fragLenSizes))
fragLenPlot <- ggplot(toPlot, aes(x = InsertSize, y = Count)) + geom_line() + theme_bw()

fragLenPlot <- fragLenPlot + scale_y_continuous(trans = "log2") + geom_vline(xintercept = c(180, 
    247), colour = "red") + geom_vline(xintercept = c(315, 437), colour = "darkblue") + 
    geom_vline(xintercept = c(100), colour = "darkgreen") + theme_bw()

# insert size less than
cutnrun_reads_filt <- cutnrun_reads[insertSizes < 300,]

# assessing fragment reproducibility ----
samples_metada <- read_csv("/home/peter_r/cutnrun_data/postprocessing/sample_table_postprocessing.csv")
sampleList <-  c("Patient_H3K27Ac_R1", "Patient_H3K27Ac_R2", "ND_JBe_H3K27Ac_R1", "ND_JBe_H3K27Ac_R2", "ND_JBe_Helios_R2", "ND_JBe_Helios_R1", "Patient_Helios_R1", "Patient_Helios_R2", "ND_JBe_HDAC1_R1", "ND_JBe_HDAC1_R2", "Patient_HDAC1_R2", "Patient_HDAC1_R2")
#sampleList <- sampleList %>% dplyr::filter()
reprod = c()
fragCount = NULL
for(hist in sampleList){
  
  if(is.null(fragCount)){
    # "_bowtie2.fragmentsCount.bin500.bed"
    fragCount = read.table(paste0("/home/peter_r/cutnrun_data/postprocessing/results/", hist, "_300bp.bin500.bed"), header = FALSE) 
    colnames(fragCount) = c("chrom", "bin", hist)
  
  }else{
    # "_bowtie2.fragmentsCount.bin500.bed"
    fragCountTmp = read.table(paste0("/home/peter_r/cutnrun_data/postprocessing/results/", hist, "_300bp.bin500.bed"), header = FALSE)
    colnames(fragCountTmp) = c("chrom", "bin", hist)
    fragCount = full_join(fragCount, fragCountTmp, by = c("chrom", "bin"))
    
  }
}

M = cor(fragCount %>% dplyr::select(-c("chrom", "bin")) %>% log2(), use = "complete.obs") 

#install.packages("corrplot")
library("corrplot")
# not as crazy low correlation as in the cutnrun pipeline, but still low!?
corrplot(M, method = "color", outline = T, addgrid.col = "darkgray", order="original", addrect = 3, rect.col = "black", rect.lwd =3,cl.pos = "b", tl.col = "indianred4", tl.cex = 1, cl.cex = 1, addCoef.col = "black", number.digits = 2, number.cex = 1, col =colorRampPalette(c("midnightblue","white","darkred"))(100))
```
